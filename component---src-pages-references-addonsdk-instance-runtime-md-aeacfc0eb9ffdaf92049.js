"use strict";(self.webpackChunkdev_site_documentation_template=self.webpackChunkdev_site_documentation_template||[]).push([[887],{60867:function(e,n,t){t.r(n),t.d(n,{_frontmatter:function(){return o},default:function(){return s}});var a=t(87462),d=t(45987),i=(t(15007),t(64983)),r=t(91515);const m=["components"],o={},l={_frontmatter:o},p=r.Z;function s(e){let{components:n}=e,t=(0,d.Z)(e,m);return(0,i.mdx)(p,(0,a.Z)({},l,t,{components:n,mdxType:"MDXLayout"}),(0,i.mdx)("h1",{id:"addonsdkinstanceruntime"},"AddOnSdk.instance.runtime"),(0,i.mdx)("p",null,"Represents the runtime of the current add-on."),(0,i.mdx)("h2",{id:"properties"},"Properties"),(0,i.mdx)("h3",{id:"type"},(0,i.mdx)("inlineCode",{parentName:"h3"},"type")),(0,i.mdx)("p",null,"The ",(0,i.mdx)("a",{parentName:"p",href:"addonsdk-constants.md"},"RuntimeType")," constant representing the entrypoint creating this backend object (ie: ",(0,i.mdx)("inlineCode",{parentName:"p"},'"panel"'),", ",(0,i.mdx)("inlineCode",{parentName:"p"},'"dialog"')," or ",(0,i.mdx)("inlineCode",{parentName:"p"},'"script"'),")."),(0,i.mdx)("h3",{id:"dialog"},(0,i.mdx)("a",{parentName:"h3",href:"../addonsdk/runtime-dialog.md"},(0,i.mdx)("inlineCode",{parentName:"a"},"Dialog"))),(0,i.mdx)("p",null,"(Optional) When the ",(0,i.mdx)("inlineCode",{parentName:"p"},"RuntimeType")," is ",(0,i.mdx)("inlineCode",{parentName:"p"},'"dialog"'),", this object will contain the reference to the ",(0,i.mdx)("a",{parentName:"p",href:"runtime-dialog.md"},"modal dialog")," the add-on invoked, and can be used to programmatically close the dialog and send results back to the caller. Will be ",(0,i.mdx)("inlineCode",{parentName:"p"},"undefined")," when no modal dialog is present. Check out the ",(0,i.mdx)("a",{parentName:"p",href:"../../guides/develop/use_cases.md#modal-dialogs"},"modal dialogs use case examples")," for more details on using dialogs, as well as the related ",(0,i.mdx)("a",{parentName:"p",href:"../addonsdk/addonsdk-app.md#showmodaldialog"},(0,i.mdx)("inlineCode",{parentName:"a"},"showModalDialog")," method"),"."),(0,i.mdx)("h2",{id:"experimental-methods"},"Experimental Methods"),(0,i.mdx)("p",null,"The following methods allow you to communicate bidirectionally between the add-on running in the iframe and the ",(0,i.mdx)("a",{parentName:"p",href:"../authoring/"},"authoring sandbox")," environments."),(0,i.mdx)("p",null,(0,i.mdx)("strong",{parentName:"p"},"IMPORTANT:")," These methods are currently ",(0,i.mdx)("strong",{parentName:"p"},(0,i.mdx)("em",{parentName:"strong"},"experimental only"))," and should not be used in any add-ons you will be distributing until they have been deemed stable. To use these methods, you will first need to set the ",(0,i.mdx)("inlineCode",{parentName:"p"},"experimentalApis")," flag to ",(0,i.mdx)("inlineCode",{parentName:"p"},"true")," in the ",(0,i.mdx)("a",{parentName:"p",href:"../manifest/index.md#requirements"},(0,i.mdx)("inlineCode",{parentName:"a"},"requirements"))," section of the ",(0,i.mdx)("inlineCode",{parentName:"p"},"manifest.json"),"."),(0,i.mdx)("h3",{id:"exposeapi"},"exposeApi()"),(0,i.mdx)("p",null,"Use this method to expose an API from your UI code running in the iframe to another runtime (ie: the ",(0,i.mdx)("a",{parentName:"p",href:"../authoring/"},"authoring sandbox code")," defined in your ",(0,i.mdx)("inlineCode",{parentName:"p"},"code.js")," for instance)."),(0,i.mdx)("h4",{id:"signature"},"Signature"),(0,i.mdx)("p",null,(0,i.mdx)("inlineCode",{parentName:"p"},"exposeApi<T>(obj: T): void")),(0,i.mdx)("h4",{id:"parameters"},"Parameters"),(0,i.mdx)("table",null,(0,i.mdx)("thead",{parentName:"table"},(0,i.mdx)("tr",{parentName:"thead"},(0,i.mdx)("th",{parentName:"tr",align:null},"Name"),(0,i.mdx)("th",{parentName:"tr",align:null},"Type"),(0,i.mdx)("th",{parentName:"tr",align:"right"},"Description"))),(0,i.mdx)("tbody",{parentName:"table"},(0,i.mdx)("tr",{parentName:"tbody"},(0,i.mdx)("td",{parentName:"tr",align:null},(0,i.mdx)("inlineCode",{parentName:"td"},"obj")),(0,i.mdx)("td",{parentName:"tr",align:null},(0,i.mdx)("inlineCode",{parentName:"td"},"object")),(0,i.mdx)("td",{parentName:"tr",align:"right"},"The concrete object/class instance to expose to other runtimes. This method call is allowed only once. Subsequent calls are ignored. ",(0,i.mdx)("strong",{parentName:"td"},"Note"),": you cannot expose entire classes from one runtime and create an instance of that class in another.")))),(0,i.mdx)("h3",{id:"apiproxy"},"apiProxy()"),(0,i.mdx)("p",null,"Requests a promise-based proxy object from another runtime to be used to call the APIs exposed by that other runtime via the ",(0,i.mdx)("inlineCode",{parentName:"p"},"exposeApi")," method."),(0,i.mdx)("h4",{id:"signature-1"},"Signature"),(0,i.mdx)("p",null,(0,i.mdx)("inlineCode",{parentName:"p"},"async apiProxy(runtimeType: RuntimeType): Promise<Remote<unknown>>")),(0,i.mdx)("h4",{id:"parameters-1"},"Parameters"),(0,i.mdx)("table",null,(0,i.mdx)("thead",{parentName:"table"},(0,i.mdx)("tr",{parentName:"thead"},(0,i.mdx)("th",{parentName:"tr",align:null},"Name"),(0,i.mdx)("th",{parentName:"tr",align:null},"Type"),(0,i.mdx)("th",{parentName:"tr",align:"right"},"Description"))),(0,i.mdx)("tbody",{parentName:"table"},(0,i.mdx)("tr",{parentName:"tbody"},(0,i.mdx)("td",{parentName:"tr",align:null},(0,i.mdx)("inlineCode",{parentName:"td"},"runtimeType")),(0,i.mdx)("td",{parentName:"tr",align:null},(0,i.mdx)("inlineCode",{parentName:"td"},"RuntimeType")),(0,i.mdx)("td",{parentName:"tr",align:"right"},'The runtime type to create the proxy object from (ie: "script" for instance, which maps to the code referenced in the ',(0,i.mdx)("a",{parentName:"td",href:"../authoring/index.md#script-entry-point"},(0,i.mdx)("inlineCode",{parentName:"a"},"script")," entryPoint")," in your add-on's ",(0,i.mdx)("inlineCode",{parentName:"td"},"manifest.js")," file).")))),(0,i.mdx)("h4",{id:"return"},"Return"),(0,i.mdx)("p",null,"A promise which resolves to an API proxy object exposed by the desired runtime as soon as the other runtime is finished initializing."),(0,i.mdx)("p",null,(0,i.mdx)("strong",{parentName:"p"},"Note:")," Calling the method again for the same runtime type will return a new proxy object without any behavior difference."),(0,i.mdx)("h4",{id:"example-usage"},"Example Usage"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-js"},'AddOnSdk.ready.then(async () => {\n    console.log("AddOnSdk is ready for use.");\n    const { runtime } = AddOnSdk.instance;\n\n    let createShapesButton = document.getElementById("createShapesButton");\n    createShapesButton.addEventListener("click", async (e) => {\n        const scriptApis = await runtime.apiProxy("script");\n        try {\n            let result = await scriptApis.createShapes();\n            console.log(result);\n        } catch (exc) {\n            console.error(exc.message, exc.stack);\n        }\n        \n    });\n});\n')))}s.isMDXComponent=!0}}]);
//# sourceMappingURL=component---src-pages-references-addonsdk-instance-runtime-md-aeacfc0eb9ffdaf92049.js.map
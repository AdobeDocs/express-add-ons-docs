"use strict";(self.webpackChunkdev_site_documentation_template=self.webpackChunkdev_site_documentation_template||[]).push([[3811],{34215:function(e,n,t){t.r(n),t.d(n,{_frontmatter:function(){return i},default:function(){return g}});var a=t(58168),r=t(80045),o=(t(88763),t(15680)),s=t(83407);const d=["components"],i={},l=e=>function(n){return console.warn("Component "+e+" was not imported, exported, or provided by MDXProvider as global scope"),(0,o.mdx)("div",n)},p=l("InlineAlert"),c=l("CodeBlock"),m={_frontmatter:i},x=s.A;function g(e){let{components:n}=e,t=(0,r.A)(e,d);return(0,o.mdx)(x,(0,a.A)({},m,t,{components:n,mdxType:"MDXLayout"}),(0,o.mdx)("h1",{id:"create-a-markdown-parser-add-on-with-the-text-api"},"Create a Markdown Parser Add-on with the Text API"),(0,o.mdx)("p",null,"Learn how to build from scratch an Adobe Express add-on capable of parsing Markdown files and converting them into rich text directly within an Adobe Express document."),(0,o.mdx)("p",null,(0,o.mdx)("img",{parentName:"p",src:"/express-add-ons-docs/assets/ae6178b48fc8bf6c593bf5112497991a/markdown--add-on.gif",alt:"Markdown Parser complete add-on"})),(0,o.mdx)("h2",{id:"introduction"},"Introduction"),(0,o.mdx)("p",null,"Welcome to this hands-on tutorial where we'll build a complete Markdown Parser add-on. It will provide a way for your users to import Markdown documents and see them instantly transformed into styled text elements inside Adobe Express, respecting formatting like headings, bold, italics, and lists."),(0,o.mdx)(p,{variant:"info",slots:"header, text1",mdxType:"InlineAlert"}),(0,o.mdx)("p",null,"What's Markdown?"),(0,o.mdx)("p",null,"Markdown is a popular lightweight markup language, widely used for formatting textual content quickly and intuitively."),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-md"},"# Markdown sample ‚Äì heading\n\nFor example, this is **bold**, _italic_ and even `monospace` text.\nIt can do much more!\n")),(0,o.mdx)("h3",{id:"what-youll-learn"},"What you'll learn"),(0,o.mdx)("ul",null,(0,o.mdx)("li",{parentName:"ul"},"Creating an interactive ",(0,o.mdx)("strong",{parentName:"li"},"drag-and-drop user interface")," with ",(0,o.mdx)("strong",{parentName:"li"},"Spectrum Web Components"),"."),(0,o.mdx)("li",{parentName:"ul"},"Integrating ",(0,o.mdx)("strong",{parentName:"li"},"file upload")," and parsing mechanisms."),(0,o.mdx)("li",{parentName:"ul"},"The power of the ",(0,o.mdx)("strong",{parentName:"li"},"Text API"),"."),(0,o.mdx)("li",{parentName:"ul"},"Applying ",(0,o.mdx)("strong",{parentName:"li"},"fonts")," using the Document API."),(0,o.mdx)("li",{parentName:"ul"},"Advanced ",(0,o.mdx)("strong",{parentName:"li"},"character styling"),": font size and weight."),(0,o.mdx)("li",{parentName:"ul"},"Advanced ",(0,o.mdx)("strong",{parentName:"li"},"paragraph styling"),": alignment and list styles.")),(0,o.mdx)("h3",{id:"what-youll-build"},"What you'll build"),(0,o.mdx)("p",null,"The add-on will feature a drag-and-drop area for uploading Markdown files and a button to parse the content. It'll read and interpret the Markdown file, and use the Text API to create and insert a Text node with the appropriate Character and Paragraph styles."),(0,o.mdx)("h3",{id:"prerequisites"},"Prerequisites"),(0,o.mdx)("p",null,"Before diving into the tutorial, ensure you have:"),(0,o.mdx)("ul",null,(0,o.mdx)("li",{parentName:"ul"},"An ",(0,o.mdx)("strong",{parentName:"li"},"Adobe account")," (use your existing Adobe ID or ",(0,o.mdx)("a",{parentName:"li",href:"https://account.adobe.com/"},"create one for free"),")."),(0,o.mdx)("li",{parentName:"ul"},"Basic knowledge of ",(0,o.mdx)("strong",{parentName:"li"},"HTML, CSS, and JavaScript"),"."),(0,o.mdx)("li",{parentName:"ul"},(0,o.mdx)("strong",{parentName:"li"},"Node.js")," installed (version 18 or newer is recommended)."),(0,o.mdx)("li",{parentName:"ul"},"A ",(0,o.mdx)("strong",{parentName:"li"},"text editor or IDE")," of your choice."),(0,o.mdx)("li",{parentName:"ul"},"Experience with Adobe Express add-ons. If you're new or need a refresher, review the ",(0,o.mdx)("a",{parentName:"li",href:"https://developer.adobe.com/express/add-ons/docs/guides/getting-started/quickstart/"},"Quickstart Guide"),".")),(0,o.mdx)("h3",{id:"difficulty"},"Difficulty"),(0,o.mdx)("p",null,"This tutorial is designed for intermediate developers who are comfortable with JavaScript and the Adobe Express add-on SDK."),(0,o.mdx)("h2",{id:"1-project-setup"},"1. Project Setup"),(0,o.mdx)("p",null,"We'll start by setting up the foundational structure for our add-on."),(0,o.mdx)("h3",{id:"11-environment-setup"},"1.1 Environment Setup"),(0,o.mdx)("p",null,"First, let's get your development environment ready. Download the ",(0,o.mdx)("a",{parentName:"p",href:"https://github.com/AdobeDocs/express-add-on-samples/tree/main/document-sandbox-samples/express-markdown-parser-addon/express-markdown-parser-addon-start"},"Markdown Parser Add-on")," from GitHub."),(0,o.mdx)("p",null,"The ",(0,o.mdx)("inlineCode",{parentName:"p"},"express-markdown-parser-addon-start")," folder follows a simple and organized structure:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-txt"},".\n‚îú‚îÄ‚îÄ package.json             üì¶ Project configuration\n‚îú‚îÄ‚îÄ webpack.config.js        üîß Build configuration\n‚îú‚îÄ‚îÄ src\n‚îÇ   ‚îú‚îÄ‚îÄ index.html           üåê UI container\n‚îÇ   ‚îú‚îÄ‚îÄ ui\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ index.js         üíª UI logic\n‚îÇ   ‚îî‚îÄ‚îÄ sandbox\n‚îÇ       ‚îî‚îÄ‚îÄ code.js          üìù Document Sandbox API logic\n")),(0,o.mdx)("p",null,"We'll add a few files and packages along the way, but this is the starting point, which comes from a slightly adapted ",(0,o.mdx)("a",{parentName:"p",href:"../../../getting_started/local_development/dev_tooling.md#templates"},"CLI template"),"."),(0,o.mdx)("h3",{id:"12-initial-code"},"1.2 Initial Code"),(0,o.mdx)("p",null,'The sample starts with a simple "Hello World" setup to ensure the communication bridge between the UI and the document sandbox is working.'),(0,o.mdx)("p",null,"Here is a breakdown of this initial setup:"),(0,o.mdx)("ul",null,(0,o.mdx)("li",{parentName:"ul"},"The ",(0,o.mdx)("inlineCode",{parentName:"li"},"index.html")," file provides the ",(0,o.mdx)("strong",{parentName:"li"},"basic UI"),", with a single button wrapped in ",(0,o.mdx)("inlineCode",{parentName:"li"},"<sp-theme>")," to match the Adobe Express style."),(0,o.mdx)("li",{parentName:"ul"},"In ",(0,o.mdx)("inlineCode",{parentName:"li"},"ui/index.js"),", the script waits for the Add-on SDK to be ready (",(0,o.mdx)("inlineCode",{parentName:"li"},"addOnUISdk.ready"),")."),(0,o.mdx)("li",{parentName:"ul"},"It then creates a ",(0,o.mdx)("inlineCode",{parentName:"li"},"sandboxProxy")," by calling ",(0,o.mdx)("inlineCode",{parentName:"li"},'runtime.apiProxy("documentSandbox")'),". This proxy is the communication link to the document sandbox."),(0,o.mdx)("li",{parentName:"ul"},"An event listener on the button uses this proxy to call the ",(0,o.mdx)("inlineCode",{parentName:"li"},"sayHello")," function."),(0,o.mdx)("li",{parentName:"ul"},"In ",(0,o.mdx)("inlineCode",{parentName:"li"},"sandbox/code.js"),", the ",(0,o.mdx)("inlineCode",{parentName:"li"},"runtime.exposeApi()")," method makes the ",(0,o.mdx)("inlineCode",{parentName:"li"},"sayHello")," function available to the UI."),(0,o.mdx)("li",{parentName:"ul"},"This two-way communication setup is fundamental for add-ons that interact with the document. Clicking the button now proves that our UI and sandbox can communicate successfully and ",(0,o.mdx)("strong",{parentName:"li"},"logs a message")," to the console.")),(0,o.mdx)(c,{slots:"heading, code",repeat:"3",languages:"index.html, ui/index.js, sandbox/code.js",mdxType:"CodeBlock"}),(0,o.mdx)("h4",{id:"indexhtml"},"index.html"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-html"},'<!DOCTYPE html>\n<html lang="en">\n<head>\n  <meta charset="UTF-8" />\n  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>\n  <title>Markdown Parser add-on</title>\n  <link rel="stylesheet" href="styles.css"/>\n</head>\n\n<body>\n  <sp-theme scale="medium" color="light" system="express">\n    <h2>Markdown Parser</h2>\n    <sp-button id="helloButton">Say Hello</sp-button>\n  </sp-theme>\n</body>\n</html>\n')),(0,o.mdx)("h4",{id:"uiindexjs"},"ui/index.js"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-javascript"},'import "@spectrum-web-components/styles/typography.css";\nimport "@spectrum-web-components/theme/src/themes.js";\nimport "@spectrum-web-components/theme/theme-light.js";\nimport "@spectrum-web-components/theme/express/theme-light.js";\nimport "@spectrum-web-components/theme/express/scale-medium.js";\nimport "@spectrum-web-components/theme/sp-theme.js";\nimport "@spectrum-web-components/button/sp-button.js";\n\nimport addOnUISdk from "https://express.adobe.com/static/add-on-sdk/sdk.js";\n\naddOnUISdk.ready.then(async () => {\n  console.log("addOnUISdk is ready for use.");\n\n  // Get the Authoring Sandbox\n  const { runtime } = addOnUISdk.instance;\n  const sandboxProxy = await runtime.apiProxy("documentSandbox");\n\n  // Log the message to the console when the button is clicked\n  document.getElementById("helloButton").addEventListener("click", () => {\n    sandboxProxy.sayHello("from the UI");\n  });\n});\n')),(0,o.mdx)("h4",{id:"sandboxcodejs"},"sandbox/code.js"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-javascript"},'import addOnSandboxSdk from "add-on-sdk-document-sandbox";\nconst { runtime } = addOnSandboxSdk.instance;\n\nfunction start() {\n  // APIs to be exposed to the UI runtime\n  const sandboxApi = {\n    sayHello: (message) => {\n      console.log(`Hello ${message}, the sandbox is also running.`);\n    },\n  };\n  runtime.exposeApi(sandboxApi);\n}\n\nstart();\n')),(0,o.mdx)("p",null,(0,o.mdx)("span",{parentName:"p",className:"gatsby-resp-image-wrapper",style:{position:"relative",display:"block",marginLeft:"auto",marginRight:"auto",maxWidth:"1280px"}},"\n      ",(0,o.mdx)("span",{parentName:"span",className:"gatsby-resp-image-background-image",style:{paddingBottom:"57.50000000000001%",position:"relative",bottom:"0",left:"0",display:"block",transition:"opacity 0.5s 0.5s",pointerEvents:"none"}}),"\n  ",(0,o.mdx)("picture",{parentName:"span"},"\n          ",(0,o.mdx)("source",{parentName:"picture",srcSet:["/express-add-ons-docs/static/fbaca33425c4f6d6b2e5be9a37118409/5530d/markdown--hello.webp 320w","/express-add-ons-docs/static/fbaca33425c4f6d6b2e5be9a37118409/0c8fb/markdown--hello.webp 640w","/express-add-ons-docs/static/fbaca33425c4f6d6b2e5be9a37118409/94b1e/markdown--hello.webp 1280w","/express-add-ons-docs/static/fbaca33425c4f6d6b2e5be9a37118409/0b34d/markdown--hello.webp 1920w","/express-add-ons-docs/static/fbaca33425c4f6d6b2e5be9a37118409/f3963/markdown--hello.webp 2500w"],sizes:"(max-width: 1280px) 100vw, 1280px",type:"image/webp"}),"\n          ",(0,o.mdx)("source",{parentName:"picture",srcSet:["/express-add-ons-docs/static/fbaca33425c4f6d6b2e5be9a37118409/dd4a7/markdown--hello.png 320w","/express-add-ons-docs/static/fbaca33425c4f6d6b2e5be9a37118409/0f09e/markdown--hello.png 640w","/express-add-ons-docs/static/fbaca33425c4f6d6b2e5be9a37118409/bbbf7/markdown--hello.png 1280w","/express-add-ons-docs/static/fbaca33425c4f6d6b2e5be9a37118409/ac7a9/markdown--hello.png 1920w","/express-add-ons-docs/static/fbaca33425c4f6d6b2e5be9a37118409/6482f/markdown--hello.png 2500w"],sizes:"(max-width: 1280px) 100vw, 1280px",type:"image/png"}),"\n          ",(0,o.mdx)("img",{parentName:"picture",className:"gatsby-resp-image-image",src:"/express-add-ons-docs/static/fbaca33425c4f6d6b2e5be9a37118409/bbbf7/markdown--hello.png",alt:"Hello World",title:"Hello World",loading:"lazy",style:{width:"100%",height:"100%",margin:"0",verticalAlign:"middle",position:"absolute",opacity:"0",transition:"opacity 0.5s",color:"inherit",boxShadow:"inset 0px 0px 0px 400px none",top:"0",left:"0"}}),"\n        "),"\n    ")),(0,o.mdx)("h2",{id:"2-build-the-ui-and-handle-files"},"2. Build the UI and Handle Files"),(0,o.mdx)("p",null,"Now, let's create the actual user interface for our add-on and implement the file handling logic."),(0,o.mdx)("h3",{id:"21-design-the-ui-with-spectrum-web-components"},"2.1 Design the UI with Spectrum Web Components"),(0,o.mdx)("p",null,"We'll use Spectrum Web Components (SWC) to create a UI that feels native to Adobe Express. Our interface will have a dropzone for files, a button to trigger parsing, and a progress indicator. The project has already imported the Spectrum Theme and Button components, let's add the other ones we need."),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-bash"},"npm install @spectrum-web-components/dropzone \\\n            @spectrum-web-components/illustrated-message \\\n            @spectrum-web-components/link \\\n            @spectrum-web-components/progress-circle\n")),(0,o.mdx)("p",null,"Update ",(0,o.mdx)("inlineCode",{parentName:"p"},"src/index.html")," with the following markup."),(0,o.mdx)("ul",null,(0,o.mdx)("li",{parentName:"ul"},"The core of the UI is the ",(0,o.mdx)("inlineCode",{parentName:"li"},"<sp-dropzone>")," component, which creates an intuitive ",(0,o.mdx)("strong",{parentName:"li"},"drag-and-drop area")," for files."),(0,o.mdx)("li",{parentName:"ul"},"For accessibility, a standard ",(0,o.mdx)("inlineCode",{parentName:"li"},'<input type="file">')," is included but hidden with CSS."),(0,o.mdx)("li",{parentName:"ul"},"A ",(0,o.mdx)("inlineCode",{parentName:"li"},"<sp-link>")," element is used to programmatically trigger the hidden file input, providing an alternative clickable way to handle file uploads."),(0,o.mdx)("li",{parentName:"ul"},"The main ",(0,o.mdx)("inlineCode",{parentName:"li"},"<sp-button>")," is initially ",(0,o.mdx)("inlineCode",{parentName:"li"},"disabled"),". This is a good practice to prevent user actions before the add-on is ready or before a file has been loaded. It will be enabled programmatically.")),(0,o.mdx)(c,{slots:"heading, code",repeat:"2",languages:"index.html, styles.css",mdxType:"CodeBlock"}),(0,o.mdx)("h4",{id:"indexhtml-1"},"index.html"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-html"},'<!DOCTYPE html>\n<html lang="en">\n<head>\n  <meta charset="UTF-8" />\n  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>\n  <title>Markdown Parser add-on</title>\n  <link rel="stylesheet" href="styles.css"/>\n</head>\n\n<body>\n  <sp-theme scale="medium" color="light" system="express">\n    <h2>Markdown Parser</h2>\n    <div class="row">\n      <sp-dropzone tabindex="0" id="dropzone" drop-effect="copy">\n        <sp-illustrated-message id="message"\n          style="--mod-illustrated-message-display: flex;"\n          heading="Drag and drop your file">\n          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 150 103"\n               width="150" height="103">\n            <path\n              d="M133.7,8.5h-118c-1.9,0-3.5,1.6-3.5,3.5v27c0,0.8,0.7,1.5,1.5,1.5s1.5-0.7,1.5-1.5V23.5h119V92c0,0.3-0.2,0.5-0.5,0.5h-118c-0.3,0-0.5-0.2-0.5-0.5V69c0-0.8-0.7-1.5-1.5-1.5s-1.5,0.7-1.5,1.5v23c0,1.9,1.6,3.5,3.5,3.5h118c1.9,0,3.5-1.6,3.5-3.5V12C137.2,10.1,135.6,8.5,133.7,8.5z M15.2,21.5V12c0-0.3,0.2-0.5,0.5-0.5h118c0.3,0,0.5,0.2,0.5,0.5v9.5H15.2z M32.6,16.5c0,0.6-0.4,1-1,1h-10c-0.6,0-1-0.4-1-1s0.4-1,1-1h10C32.2,15.5,32.6,15.9,32.6,16.5z M13.6,56.1l-8.6,8.5C4.8,65,4.4,65.1,4,65.1c-0.4,0-0.8-0.1-1.1-0.4c-0.6-0.6-0.6-1.5,0-2.1l8.6-8.5l-8.6-8.5c-0.6-0.6-0.6-1.5,0-2.1c0.6-0.6,1.5-0.6,2.1,0l8.6,8.5l8.6-8.5c0.6-0.6,1.5-0.6,2.1,0c0.6,0.6,0.6,1.5,0,2.1L15.8,54l8.6,8.5c0.6,0.6,0.6,1.5,0,2.1c-0.3,0.3-0.7,0.4-1.1,0.4c-0.4,0-0.8-0.1-1.1-0.4L13.6,56.1z">\n            </path>\n          </svg>\n        </sp-illustrated-message>\n        <div>\n          <label for="file-input">\n            <sp-link href="#"\n              onclick="document.getElementById(\'file-input\').click()">\n              Select a Markdown File\n            </sp-link>\n            from your computer\n          </label>\n          <input type="file" id="file-input" style="display: none" />\n        </div>\n      </sp-dropzone>\n    </div>\n\n    <div class="row button-row">\n      <sp-button id="parseButton" variant="accent" disabled>\n        Parse Markdown\n      </sp-button>\n      <sp-progress-circle size="s" indeterminate id="progress-circle">\n      </sp-progress-circle>\n    </div>\n\n    <div class="row info-text">\n      <p>\n        Parses Markdown and creates styled text in your Adobe Express\n        document. Supported formats: Headings, Bold, Italic, and Lists.\n      </p>\n    </div>\n  </sp-theme>\n</body>\n</html>\n')),(0,o.mdx)("h4",{id:"stylescss"},"styles.css"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-css"},"body { margin: 0; padding: 0; overflow-x: hidden; }\n\nsp-theme {\n  margin: 0 var(--spectrum-global-dimension-static-size-300);\n  display: grid;\n}\n\nh2 { font-weight: var(--spectrum-global-font-weight-black); }\n\nsp-button { flex: 1; }\n\nsp-dropzone { max-width: 272px; }\n\nsp-progress-circle { margin-left: 10px; }\n\n.row {\n  display: flex; flex-direction: row; justify-content: space-between;\n  width: 100%; align-items: flex-end;\n}\n\n.button-row {\n  margin-top: 20px; display: flex; align-items: center;\n  justify-content: center;\n}\n\n.gap-20 { gap: var(--spectrum-global-dimension-static-size-250); }\n\n.gutter-row {\n  display: flex; flex-direction: row; justify-content: flex-end;\n  align-items: flex-start; border: 1px solid black; width: 100%;\n  margin-bottom: var(--spectrum-global-dimension-static-size-150);\n}\n\n.info-text { margin-top: 10px; font-size: 12px; color: #6e6e6e; }\n")),(0,o.mdx)("h3",{id:"22-handle-file-uploads"},"2.2 Handle File Uploads"),(0,o.mdx)("p",null,"To handle file interactions, we'll create a new file called ",(0,o.mdx)("inlineCode",{parentName:"p"},"ui/file-handler.js"),". This module will ",(0,o.mdx)("strong",{parentName:"p"},"set up event listeners")," on the dropzone and the hidden file input. We'll also touch the ",(0,o.mdx)("inlineCode",{parentName:"p"},"ui/index.js")," file to import and pass it the sandbox proxy."),(0,o.mdx)("p",null,"Let's walk through the file handling logic in ",(0,o.mdx)("inlineCode",{parentName:"p"},"ui/file-handler.js"),":"),(0,o.mdx)("ul",null,(0,o.mdx)("li",{parentName:"ul"},"The ",(0,o.mdx)("inlineCode",{parentName:"li"},"setupFileHandler")," function ",(0,o.mdx)("strong",{parentName:"li"},"centralizes all UI interaction logic"),", and begins by getting references to the necessary DOM elements (dropzone, button, etc.)."),(0,o.mdx)("li",{parentName:"ul"},"The ",(0,o.mdx)("inlineCode",{parentName:"li"},"handleFile")," function is the workhorse here. It first validates that the dropped file is a Markdown file."),(0,o.mdx)("li",{parentName:"ul"},"It then uses the browser's standard ",(0,o.mdx)("inlineCode",{parentName:"li"},"FileReader")," API to read the file's content asynchronously."),(0,o.mdx)("li",{parentName:"ul"},"Once the content is loaded (",(0,o.mdx)("inlineCode",{parentName:"li"},"reader.onload"),'), it\'s stored in a variable, and the "Parse Markdown" button is enabled. The ',(0,o.mdx)("inlineCode",{parentName:"li"},"updateMessage"),' function is called to update the message to "Got it!"'),(0,o.mdx)("li",{parentName:"ul"},"Event listeners are set up for both the Spectrum dropzone's custom ",(0,o.mdx)("inlineCode",{parentName:"li"},"sp-dropzone-drop")," event and the standard ",(0,o.mdx)("inlineCode",{parentName:"li"},"change")," event on the hidden file input, ensuring both upload methods work.")),(0,o.mdx)("p",null,"In ",(0,o.mdx)("inlineCode",{parentName:"p"},"ui/index.js"),", instead:"),(0,o.mdx)("ul",null,(0,o.mdx)("li",{parentName:"ul"},"We import all the necessary Spectrum components that we installed earlier."),(0,o.mdx)("li",{parentName:"ul"},"The ",(0,o.mdx)("inlineCode",{parentName:"li"},"sandboxProxy")," is retrieved from the runtime API and passed to ",(0,o.mdx)("inlineCode",{parentName:"li"},"setupFileHandler()"),".")),(0,o.mdx)(c,{slots:"heading, code",repeat:"2",languages:"JavaScript, JavaScript",mdxType:"CodeBlock"}),(0,o.mdx)("h4",{id:"uiindexjs-1"},"ui/index.js"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-javascript"},'import "@spectrum-web-components/styles/typography.css";\n\nimport "@spectrum-web-components/theme/src/themes.js";\nimport "@spectrum-web-components/theme/theme-light.js";\nimport "@spectrum-web-components/theme/express/theme-light.js";\nimport "@spectrum-web-components/theme/express/scale-medium.js";\nimport "@spectrum-web-components/theme/sp-theme.js";\n\nimport "@spectrum-web-components/button/sp-button.js";\nimport "@spectrum-web-components/link/sp-link.js";\nimport "@spectrum-web-components/illustrated-message/sp-illustrated-message.js";\nimport "@spectrum-web-components/dropzone/sp-dropzone.js";\nimport "@spectrum-web-components/progress-circle/sp-progress-circle.js";\n\nimport addOnUISdk from "https://express.adobe.com/static/add-on-sdk/sdk.js";\nimport setupFileHandler from "./file-handler.js";\n\naddOnUISdk.ready.then(async () => {\n  console.log("addOnUISdk is ready for use.");\n\n  // Get the Authoring Sandbox\n  const { runtime } = addOnUISdk.instance;\n  const sandboxProxy = await runtime.apiProxy("documentSandbox");\n\n  // Pass the sandbox proxy to the file handler\n  setupFileHandler(sandboxProxy); // üëà\n});\n')),(0,o.mdx)("h4",{id:"uifile-handlerjs"},"ui/file-handler.js"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-javascript"},'// Sets up file handling functionality for the markdown parser add-on\nexport default function setupFileHandler(sandboxProxy) {\n  customElements.whenDefined("sp-dropzone").then(() => {\n    const dropzone = document.getElementById("dropzone");\n    const parseButton = document.getElementById("parseButton");\n    const message = document.getElementById("message");\n    const fileInput = document.getElementById("file-input");\n    const progressCircle = document.getElementById("progress-circle");\n    let input;\n    let beingDraggedOver = false;\n    let markdownContent = null;\n\n    // Hide progress initially\n    if (progressCircle) { progressCircle.style.display = "none" }\n\n    const isMarkdownFile = (file) => {\n      return (\n        file.name.toLowerCase().endsWith(".md") ||\n        file.type === "text/markdown"\n      );\n    };\n\n    const updateMessage = () => {\n      message.heading =\n        input !== undefined\n          ? beingDraggedOver\n            ? "Drop here to replace!"\n            : "Got it!"\n          : "Drag and drop your file";\n    };\n\n    const handleDropOrChange = (event) => {\n      let file;\n\n      // Handle different event sources\n      if (event.type === "drop") {\n        file = event.dataTransfer.files[0];\n      } else if (event.type === "change") {\n        file = event.target.files[0];\n      } else if (event.detail && event.detail.dropEvent) {\n        // Handle sp-dropzone-drop event\n        file = event.detail.dropEvent.dataTransfer.files[0];\n      }\n      if (!file) {\n        console.error("No file found in the event"); return;\n      }\n      if (!isMarkdownFile(file)) {\n        message.heading = "Please drop a markdown (.md) file"; return;\n      }\n\n      // Set input to a temporary value to show "Got it!" immediately\n      input = "loading";\n      dropzone.setAttribute("filled", true);\n      beingDraggedOver = false;\n      updateMessage();\n\n      const reader = new FileReader();\n      reader.onload = (e) => {\n        const content = e.target.result;\n        input = content;\n        markdownContent = content;\n        console.log("Markdown content:", content);\n        // Enable parse button now that we have content\n        parseButton.disabled = false;\n        // Ensure message is updated after content is loaded\n        updateMessage();\n      };\n      reader.readAsText(file);\n    };\n\n    // Function to parse markdown and insert styled text\n    // into the document - To be implemented later...\n    const parseMarkdownAndInsert = async () => {\n      if (!markdownContent) {\n        console.error("No markdown content to parse"); return;\n      }\n      console.log("Parsing will be implemented in the next section.");\n      message.heading = "Parsing not implemented yet.";\n    };\n\n    // Event listeners\n    dropzone.addEventListener("dragover", (event) => {\n      event.preventDefault();\n      beingDraggedOver = true;\n      updateMessage();\n    });\n    dropzone.addEventListener("dragleave", () => {\n      beingDraggedOver = false;\n      updateMessage();\n    });\n    dropzone.addEventListener("drop", (event) => {\n      event.preventDefault();\n      handleDropOrChange(event);\n    });\n    // Also listen for the Spectrum Web Component\'s native event\n    dropzone.addEventListener("sp-dropzone-drop", (event) => {\n      event.preventDefault();\n      handleDropOrChange(event);\n    });\n    fileInput.addEventListener("change", (event) => {\n      handleDropOrChange(event);\n    });\n\n    // Parse button click handler\n    parseButton.addEventListener("click", parseMarkdownAndInsert);\n    // Initially disable parse button until we have content\n    parseButton.disabled = true;\n  });\n}\n')),(0,o.mdx)("p",null,(0,o.mdx)("span",{parentName:"p",className:"gatsby-resp-image-wrapper",style:{position:"relative",display:"block",marginLeft:"auto",marginRight:"auto",maxWidth:"1280px"}},"\n      ",(0,o.mdx)("span",{parentName:"span",className:"gatsby-resp-image-background-image",style:{paddingBottom:"57.50000000000001%",position:"relative",bottom:"0",left:"0",display:"block",transition:"opacity 0.5s 0.5s",pointerEvents:"none"}}),"\n  ",(0,o.mdx)("picture",{parentName:"span"},"\n          ",(0,o.mdx)("source",{parentName:"picture",srcSet:["/express-add-ons-docs/static/ddab09c6934b92c379a6c208d0dd987c/5530d/markdown--ui.webp 320w","/express-add-ons-docs/static/ddab09c6934b92c379a6c208d0dd987c/0c8fb/markdown--ui.webp 640w","/express-add-ons-docs/static/ddab09c6934b92c379a6c208d0dd987c/94b1e/markdown--ui.webp 1280w","/express-add-ons-docs/static/ddab09c6934b92c379a6c208d0dd987c/0b34d/markdown--ui.webp 1920w","/express-add-ons-docs/static/ddab09c6934b92c379a6c208d0dd987c/f3963/markdown--ui.webp 2500w"],sizes:"(max-width: 1280px) 100vw, 1280px",type:"image/webp"}),"\n          ",(0,o.mdx)("source",{parentName:"picture",srcSet:["/express-add-ons-docs/static/ddab09c6934b92c379a6c208d0dd987c/dd4a7/markdown--ui.png 320w","/express-add-ons-docs/static/ddab09c6934b92c379a6c208d0dd987c/0f09e/markdown--ui.png 640w","/express-add-ons-docs/static/ddab09c6934b92c379a6c208d0dd987c/bbbf7/markdown--ui.png 1280w","/express-add-ons-docs/static/ddab09c6934b92c379a6c208d0dd987c/ac7a9/markdown--ui.png 1920w","/express-add-ons-docs/static/ddab09c6934b92c379a6c208d0dd987c/6482f/markdown--ui.png 2500w"],sizes:"(max-width: 1280px) 100vw, 1280px",type:"image/png"}),"\n          ",(0,o.mdx)("img",{parentName:"picture",className:"gatsby-resp-image-image",src:"/express-add-ons-docs/static/ddab09c6934b92c379a6c208d0dd987c/bbbf7/markdown--ui.png",alt:"Markdown Parser UI",title:"Markdown Parser UI",loading:"lazy",style:{width:"100%",height:"100%",margin:"0",verticalAlign:"middle",position:"absolute",opacity:"0",transition:"opacity 0.5s",color:"inherit",boxShadow:"inset 0px 0px 0px 400px none",top:"0",left:"0"}}),"\n        "),"\n    ")),(0,o.mdx)("p",null,'As soon as you drop a Markdown file, the UI will show "Got it!" and the Parse Markdown button will be enabled.'),(0,o.mdx)("p",null,(0,o.mdx)("span",{parentName:"p",className:"gatsby-resp-image-wrapper",style:{position:"relative",display:"block",marginLeft:"auto",marginRight:"auto",maxWidth:"1280px"}},"\n      ",(0,o.mdx)("span",{parentName:"span",className:"gatsby-resp-image-background-image",style:{paddingBottom:"57.50000000000001%",position:"relative",bottom:"0",left:"0",display:"block",transition:"opacity 0.5s 0.5s",pointerEvents:"none"}}),"\n  ",(0,o.mdx)("picture",{parentName:"span"},"\n          ",(0,o.mdx)("source",{parentName:"picture",srcSet:["/express-add-ons-docs/static/3a0d1b74a2fe768a707384c49dfbeb25/5530d/markdown--text.webp 320w","/express-add-ons-docs/static/3a0d1b74a2fe768a707384c49dfbeb25/0c8fb/markdown--text.webp 640w","/express-add-ons-docs/static/3a0d1b74a2fe768a707384c49dfbeb25/94b1e/markdown--text.webp 1280w","/express-add-ons-docs/static/3a0d1b74a2fe768a707384c49dfbeb25/0b34d/markdown--text.webp 1920w","/express-add-ons-docs/static/3a0d1b74a2fe768a707384c49dfbeb25/f3963/markdown--text.webp 2500w"],sizes:"(max-width: 1280px) 100vw, 1280px",type:"image/webp"}),"\n          ",(0,o.mdx)("source",{parentName:"picture",srcSet:["/express-add-ons-docs/static/3a0d1b74a2fe768a707384c49dfbeb25/dd4a7/markdown--text.png 320w","/express-add-ons-docs/static/3a0d1b74a2fe768a707384c49dfbeb25/0f09e/markdown--text.png 640w","/express-add-ons-docs/static/3a0d1b74a2fe768a707384c49dfbeb25/bbbf7/markdown--text.png 1280w","/express-add-ons-docs/static/3a0d1b74a2fe768a707384c49dfbeb25/ac7a9/markdown--text.png 1920w","/express-add-ons-docs/static/3a0d1b74a2fe768a707384c49dfbeb25/6482f/markdown--text.png 2500w"],sizes:"(max-width: 1280px) 100vw, 1280px",type:"image/png"}),"\n          ",(0,o.mdx)("img",{parentName:"picture",className:"gatsby-resp-image-image",src:"/express-add-ons-docs/static/3a0d1b74a2fe768a707384c49dfbeb25/bbbf7/markdown--text.png",alt:"Markdown Parser with console text",title:"Markdown Parser with console text",loading:"lazy",style:{width:"100%",height:"100%",margin:"0",verticalAlign:"middle",position:"absolute",opacity:"0",transition:"opacity 0.5s",color:"inherit",boxShadow:"inset 0px 0px 0px 400px none",top:"0",left:"0"}}),"\n        "),"\n    ")),(0,o.mdx)("h2",{id:"3-parse-markdown"},"3. Parse Markdown"),(0,o.mdx)("p",null,"The next step is to take the raw text from the uploaded file and convert it into a structured format that we can work with."),(0,o.mdx)("h3",{id:"31-parse-markdown-into-an-abstract-syntax-tree-ast"},"3.1 Parse Markdown into an Abstract Syntax Tree (AST)"),(0,o.mdx)("p",null,"Parsing involves analyzing a Markdown text as a string and converting it into a data structure called an ",(0,o.mdx)("strong",{parentName:"p"},"Abstract Syntax Tree (AST)"),". An AST is a tree representation, where each node denotes a construct occurring in the text."),(0,o.mdx)("p",null,"For example, the Markdown ",(0,o.mdx)("inlineCode",{parentName:"p"},"## Hello")," would be parsed into a ",(0,o.mdx)("inlineCode",{parentName:"p"},"heading")," node with a ",(0,o.mdx)("inlineCode",{parentName:"p"},"depth")," of 2, containing a ",(0,o.mdx)("inlineCode",{parentName:"p"},"text"),' node with the value "Hello".'),(0,o.mdx)("p",null,"We will use two popular libraries for this task:"),(0,o.mdx)("ul",null,(0,o.mdx)("li",{parentName:"ul"},(0,o.mdx)("a",{parentName:"li",href:"https://www.npmjs.com/package/unified"},(0,o.mdx)("inlineCode",{parentName:"a"},"unified")),": A powerful engine for processing content as structured data (ASTs) with plugins."),(0,o.mdx)("li",{parentName:"ul"},(0,o.mdx)("a",{parentName:"li",href:"https://www.npmjs.com/package/remark-parse"},(0,o.mdx)("inlineCode",{parentName:"a"},"remark-parse")),": A ",(0,o.mdx)("inlineCode",{parentName:"li"},"unified")," plugin plugin that defines how to take markdown as input and turn it into a syntax tree."),(0,o.mdx)("li",{parentName:"ul"},(0,o.mdx)("a",{parentName:"li",href:"https://www.npmjs.com/package/remark-stringify"},(0,o.mdx)("inlineCode",{parentName:"a"},"remark-stringify")),": A ",(0,o.mdx)("inlineCode",{parentName:"li"},"unified")," plugin that defines how to take a syntax tree as input and turn it into serialized markdown."),(0,o.mdx)("li",{parentName:"ul"},(0,o.mdx)("a",{parentName:"li",href:"https://www.npmjs.com/package/mdast-util-to-string"},(0,o.mdx)("inlineCode",{parentName:"a"},"mdast-util-to-string")),": A tiny utility that gets the textual content of a node.")),(0,o.mdx)("p",null,"Let's install them:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-bash"},"npm install unified \\\n            remark-parse \\\n            remark-stringify \\\n            mdast-util-to-string\n")),(0,o.mdx)("h3",{id:"32-implement-the-parser"},"3.2 Implement the Parser"),(0,o.mdx)("p",null,"Now, let's create the ",(0,o.mdx)("inlineCode",{parentName:"p"},"ui/markdown-parser.js")," file. This module will be responsible for taking Markdown text and returning an AST."),(0,o.mdx)("p",null,"Here's what our parser module does:"),(0,o.mdx)("ul",null,(0,o.mdx)("li",{parentName:"ul"},(0,o.mdx)("strong",{parentName:"li"},"Parses Markdown into a Data Structure"),": At its core, the module takes the raw Markdown text from the uploaded file and uses the ",(0,o.mdx)("inlineCode",{parentName:"li"},"unified")," and ",(0,o.mdx)("inlineCode",{parentName:"li"},"remark-parse")," libraries to transform it into an Abstract Syntax Tree (AST). An AST is an organized, tree-like representation of the document's structure (headings, lists, bold text, etc.)."),(0,o.mdx)("li",{parentName:"ul"},(0,o.mdx)("strong",{parentName:"li"},"Creates a Specially Formatted Text String"),": It then traverses the AST to generate a single, continuous string of text. This isn't just plain text; the ",(0,o.mdx)("inlineCode",{parentName:"li"},"getFormattedText")," function strategically inserts double newlines (",(0,o.mdx)("inlineCode",{parentName:"li"},"\\n\\n"),") between major elements like paragraphs and headings."),(0,o.mdx)("li",{parentName:"ul"},(0,o.mdx)("strong",{parentName:"li"},"Prepares Text for Styling"),": This special formatting is key to our strategy. The single string with calculated newlines serves as the canvas upon which we'll apply styles. The newlines ensure that when the text is placed in Adobe Express, paragraphs are correctly separated. We will later use this string to calculate the exact character positions for applying styles like bold, italics, or heading sizes."),(0,o.mdx)("li",{parentName:"ul"},(0,o.mdx)("strong",{parentName:"li"},"Exports Key Information"),": The main function, ",(0,o.mdx)("inlineCode",{parentName:"li"},"processMarkdown"),", bundles up the AST and the formatted text string, making them available to the other parts of our add-on.")),(0,o.mdx)(c,{slots:"heading, code",repeat:"1",languages:"JavaScript",mdxType:"CodeBlock"}),(0,o.mdx)("h4",{id:"uimarkdown-parserjs"},"ui/markdown-parser.js"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-javascript"},'import { unified } from "unified";\nimport remarkParse from "remark-parse";\nimport remarkStringify from "remark-stringify";\nimport { toString } from "mdast-util-to-string";\n\n// Parse markdown content into an abstract syntax tree (AST)\nexport async function parseMarkdown(markdownContent) {\n  try {\n    // Create a unified processor with remark-parse\n    const processor = unified().use(remarkParse);\n    // Parse the markdown content into an AST\n    const ast = processor.parse(markdownContent);\n    // Run any transformations needed\n    const result = await processor.run(ast);\n    return result;\n  } catch (e) {\n    console.error("Error parsing markdown in markdown-parser.js:", e);\n    throw e;\n  }\n}\n\n// Replace multiple consecutive spaces, tabs,\n// and newlines with a single space\nfunction cleanText(text) { return text.replace(/\\s+/g, " ").trim() }\n\n// Get properly formatted text from the AST\nexport function getFormattedText(ast) {\n  let text = "";\n\n  // Process nodes to create proper paragraph breaks\n  const processNode = (node) => {\n    if (!node) return "";\n    if (node.type === "root") {\n      // Process each child node\n      node.children.forEach((child, index) => {\n        const childText = processNode(child);\n        text += childText;\n        // Add paragraph breaks between block elements\n        if (\n          index < node.children.length - 1 &&\n          ["paragraph", "heading", "list"].includes(child.type)\n        ) {  text += "\\n\\n" }\n      });\n      return text;\n    }\n\n    // Handle specific node types\n    switch (node.type) {\n      case "paragraph": return cleanText(toString(node));\n      case "heading":   return cleanText(toString(node));\n      case "list":\n        let listText = "";\n        node.children.forEach((item, index) => {\n          // const marker = node.ordered ? `${index + 1}. ` : "‚Ä¢ ";\n          const itemText = cleanText(toString(item));\n          // listText += marker + itemText;\n          listText += itemText;\n          if (index < node.children.length - 1) { listText += "\\n" }\n        });\n        return listText;\n      default:\n        // For other node types, just return the text\n        return cleanText(toString(node));\n    }\n  };\n  return processNode(ast);\n}\n\n// Convert AST back to markdown string (for testing/debugging)\nexport async function astToMarkdown(ast) {\n  try {\n    const processor = unified().use(remarkStringify);\n    const result = processor.stringify(ast);\n    return result;\n  } catch (e) {\n    console.error("Error converting AST to markdown:", e);\n    throw e;\n  }\n}\n\n// Extract plain text from the AST\nexport function extractTextFromAst(ast) { return toString(ast) }\n\n// Process markdown by parsing to AST + transforming for Adobe Express\nexport async function processMarkdown(markdownContent) {\n\n  const ast = await parseMarkdown(markdownContent);\n  // Extract all headings for potential TOC\n  const headings = [];\n  const processNode = (node) => {\n    if (node.type === "heading") {\n      headings.push({\n        depth: node.depth, text: toString(node),\n        children: node.children\n      });\n    }\n    if (node.children) { node.children.forEach(processNode) }\n  }\n  processNode(ast);\n\n  // Get both formatted text (with proper paragraphs) and raw text\n  const formattedText = getFormattedText(ast);\n\n  return { ast, headings, plainText: formattedText, formattedText }\n}\n')),(0,o.mdx)("h3",{id:"33-connect-the-parser"},"3.3 Connect the Parser"),(0,o.mdx)("p",null,"Now that we have a module capable of turning Markdown text into an Abstract Syntax Tree (AST), let's connect it to our UI. This will serve as a great checkpoint to verify that our file reading and parsing logic are working correctly before we move on to styling."),(0,o.mdx)("p",null,"First, import the ",(0,o.mdx)("inlineCode",{parentName:"p"},"parseMarkdown")," function at the top of ",(0,o.mdx)("inlineCode",{parentName:"p"},"src/ui/file-handler.js"),"; next, update the placeholder ",(0,o.mdx)("inlineCode",{parentName:"p"},"parseMarkdownAndInsert")," function with a new logic to call the parser and log the result to the console."),(0,o.mdx)(c,{slots:"heading, code",repeat:"1",languages:"JavaScript",mdxType:"CodeBlock"}),(0,o.mdx)("h4",{id:"uifile-handlerjs-1"},"ui/file-handler.js"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-javascript"},'import { parseMarkdown } from "./markdown-parser.js";     // üëà\n\nexport default function setupFileHandler(sandboxProxy) {\n  customElements.whenDefined("sp-dropzone").then(() => {\n\n    // üëÜ (keep the rest of the file the same) üëÜ\n\n    const parseMarkdownAndInsert = async () => {\n      if (!markdownContent) {\n        console.error("No markdown content to parse");\n        return;\n      }\n      try {\n        progressCircle.style.display = "block";\n        message.heading = "Processing markdown...";\n        parseButton.disabled = true;\n\n        // 1. Parse the markdown to get the AST           // üëà\n        const ast = await parseMarkdown(markdownContent); // üëà\n        console.log("Parsed Markdown AST:", ast);         // üëà\n\n        message.heading = "AST logged to console!";\n      } catch (error) {\n        console.error("Error during parsing:", error);\n        message.heading = "Error parsing markdown";\n      } finally {\n        progressCircle.style.display = "none";\n        parseButton.disabled = false;\n      }\n    };\n\n    // üëá (keep the rest of the file the same) üëá\n\n  });\n}\n')),(0,o.mdx)("p",null,'Now, when you run the add-on, upload a Markdown file, and click "Parse Markdown", you should see the structured AST object in your browser\'s developer console. This confirms that the core parsing mechanism is working perfectly.'),(0,o.mdx)("p",null,(0,o.mdx)("span",{parentName:"p",className:"gatsby-resp-image-wrapper",style:{position:"relative",display:"block",marginLeft:"auto",marginRight:"auto",maxWidth:"1280px"}},"\n      ",(0,o.mdx)("span",{parentName:"span",className:"gatsby-resp-image-background-image",style:{paddingBottom:"40.3125%",position:"relative",bottom:"0",left:"0",display:"block",transition:"opacity 0.5s 0.5s",pointerEvents:"none"}}),"\n  ",(0,o.mdx)("picture",{parentName:"span"},"\n          ",(0,o.mdx)("source",{parentName:"picture",srcSet:["/express-add-ons-docs/static/d8ca23aa19c0273c081cc73aee57f79b/5530d/markdown--ast.webp 320w","/express-add-ons-docs/static/d8ca23aa19c0273c081cc73aee57f79b/0c8fb/markdown--ast.webp 640w","/express-add-ons-docs/static/d8ca23aa19c0273c081cc73aee57f79b/94b1e/markdown--ast.webp 1280w","/express-add-ons-docs/static/d8ca23aa19c0273c081cc73aee57f79b/0b34d/markdown--ast.webp 1920w","/express-add-ons-docs/static/d8ca23aa19c0273c081cc73aee57f79b/f3963/markdown--ast.webp 2500w"],sizes:"(max-width: 1280px) 100vw, 1280px",type:"image/webp"}),"\n          ",(0,o.mdx)("source",{parentName:"picture",srcSet:["/express-add-ons-docs/static/d8ca23aa19c0273c081cc73aee57f79b/dd4a7/markdown--ast.png 320w","/express-add-ons-docs/static/d8ca23aa19c0273c081cc73aee57f79b/0f09e/markdown--ast.png 640w","/express-add-ons-docs/static/d8ca23aa19c0273c081cc73aee57f79b/bbbf7/markdown--ast.png 1280w","/express-add-ons-docs/static/d8ca23aa19c0273c081cc73aee57f79b/ac7a9/markdown--ast.png 1920w","/express-add-ons-docs/static/d8ca23aa19c0273c081cc73aee57f79b/6482f/markdown--ast.png 2500w"],sizes:"(max-width: 1280px) 100vw, 1280px",type:"image/png"}),"\n          ",(0,o.mdx)("img",{parentName:"picture",className:"gatsby-resp-image-image",src:"/express-add-ons-docs/static/d8ca23aa19c0273c081cc73aee57f79b/bbbf7/markdown--ast.png",alt:"Markdown Parser with console AST output",title:"Markdown Parser with console AST output",loading:"lazy",style:{width:"100%",height:"100%",margin:"0",verticalAlign:"middle",position:"absolute",opacity:"0",transition:"opacity 0.5s",color:"inherit",boxShadow:"inset 0px 0px 0px 400px none",top:"0",left:"0"}}),"\n        "),"\n    ")),(0,o.mdx)("h2",{id:"4-integrate-with-the-adobe-express-text-api"},"4. Integrate with the Adobe Express Text API"),(0,o.mdx)("p",null,"With our Markdown parsed into an AST, the final and most exciting part is to render it as styled text in the Adobe Express document."),(0,o.mdx)("h3",{id:"41-convert-the-ast-into-styled-text-for-adobe-express"},"4.1 Convert the AST into Styled Text for Adobe Express"),(0,o.mdx)("p",null,"Our overall strategy is as follows:"),(0,o.mdx)("ol",null,(0,o.mdx)("li",{parentName:"ol"},(0,o.mdx)("strong",{parentName:"li"},"Extract Plain Text"),": First, we'll convert the entire AST into a single string of plain text, using our ",(0,o.mdx)("inlineCode",{parentName:"li"},"getFormattedText")," function."),(0,o.mdx)("li",{parentName:"ol"},(0,o.mdx)("strong",{parentName:"li"},"Generate Style Ranges"),": We'll traverse the AST again. For each node that requires styling (like a ",(0,o.mdx)("inlineCode",{parentName:"li"},"heading"),", ",(0,o.mdx)("inlineCode",{parentName:"li"},"strong"),", or ",(0,o.mdx)("inlineCode",{parentName:"li"},"emphasis")," node), we'll record its ",(0,o.mdx)("inlineCode",{parentName:"li"},"type")," of style and its ",(0,o.mdx)("inlineCode",{parentName:"li"},"start")," and ",(0,o.mdx)("inlineCode",{parentName:"li"},"end")," position in the plain text string."),(0,o.mdx)("li",{parentName:"ol"},(0,o.mdx)("strong",{parentName:"li"},"Communicate with Sandbox"),": We'll send the plain text and the array of style ranges to our document sandbox."),(0,o.mdx)("li",{parentName:"ol"},(0,o.mdx)("strong",{parentName:"li"},"Apply Styles in Sandbox"),": The sandbox code will create a single ",(0,o.mdx)("inlineCode",{parentName:"li"},"TextNode")," with the plain text. Then, it will iterate through the style ranges and apply the corresponding character or paragraph styles using the Text API.")),(0,o.mdx)("h3",{id:"42-the-formatter-generating-style-ranges"},"4.2 The Formatter: Generating Style Ranges"),(0,o.mdx)("p",null,"The new ",(0,o.mdx)("inlineCode",{parentName:"p"},"ui/adobe-express-formatter.js")," module is responsible for the second step: traversing the AST and generating style ranges."),(0,o.mdx)("p",null,"This formatter's goal is to ",(0,o.mdx)("strong",{parentName:"p"},"map the AST structure to a list of styling instructions")," that Adobe Express can understand."),(0,o.mdx)("ul",null,(0,o.mdx)("li",{parentName:"ul"},"The ",(0,o.mdx)("inlineCode",{parentName:"li"},"createExpressStylingFromAST()")," function first generates the final, formatted plain text string."),(0,o.mdx)("li",{parentName:"ul"},"It then uses a recursive ",(0,o.mdx)("inlineCode",{parentName:"li"},"traverse")," function to walk through every node in the AST."),(0,o.mdx)("li",{parentName:"ul"},"The key to this process is the ",(0,o.mdx)("inlineCode",{parentName:"li"},"offset")," variable, which acts as a cursor, tracking our position within the plain text string."),(0,o.mdx)("li",{parentName:"ul"},"For each styleable node (e.g., ",(0,o.mdx)("inlineCode",{parentName:"li"},"heading"),", ",(0,o.mdx)("inlineCode",{parentName:"li"},"strong"),"), we record the ",(0,o.mdx)("inlineCode",{parentName:"li"},"offset")," before and after processing its children. This gives us the precise ",(0,o.mdx)("inlineCode",{parentName:"li"},"start")," and ",(0,o.mdx)("inlineCode",{parentName:"li"},"end")," indices for the style range."),(0,o.mdx)("li",{parentName:"ul"},"A crucial detail is handling whitespace. The traversal logic must account for the double line breaks (",(0,o.mdx)("inlineCode",{parentName:"li"},"\\n\\n"),") we added between block elements to keep the ",(0,o.mdx)("inlineCode",{parentName:"li"},"offset")," accurate. This is why the ",(0,o.mdx)("inlineCode",{parentName:"li"},"root")," node traversal manually increments the offset.")),(0,o.mdx)(c,{slots:"heading, code",repeat:"1",languages:"JavaScript",mdxType:"CodeBlock"}),(0,o.mdx)("h4",{id:"uiadobe-express-formatterjs"},"ui/adobe-express-formatter.js"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-javascript"},'import { getFormattedText, extractTextFromAst } from "./markdown-parser.js";\n\n// Creates a mapping of text ranges and their styling commands for Adobe Express\nfunction processNodeForStyling(ast, styleRanges) {\n  let offset = 0;\n\n  const traverse = (node) => {\n    if (!node) return;\n\n    const startOffset = offset;\n    // Helper function to process styled nodes with common pattern\n    const processStyledNode = (node, styleType, styleProps = {}) => {\n      const rangeStart = offset;\n      node.children.forEach(traverse);\n      const rangeEnd = offset;\n\n      styleRanges.push({\n        start: rangeStart,  end: rangeEnd,\n        style: { type: styleType, ...styleProps },\n      });\n    };\n\n    switch (node.type) {\n      case "root":\n        node.children.forEach((child, index) => {\n          traverse(child);\n          if (\n            index < node.children.length - 1 &&\n            ["paragraph", "heading", "list"].includes(child.type)\n          ) {\n            offset += 2; // \\n\\n between blocks\n          }\n        });\n        break;\n\n      case "paragraph":\n        node.children.forEach(traverse);\n        break;\n      case "heading":\n        processStyledNode(node, "heading", { level: node.depth });\n        break;\n      case "text":\n        offset += node.value.length;\n        break;\n      case "emphasis":\n        processStyledNode(node, "emphasis", { italic: true });\n        break;\n      case "strong":\n        processStyledNode(node, "strong", { bold: true });\n        break;\n\n      // example AST traversal logic for lists:\n      case "list":\n        const listStart = offset;\n        node.children.forEach((item, index) => {\n          item.children.forEach(traverse);\n          // newline between items\n          if (index < node.children.length - 1) offset += 1;\n        });\n        styleRanges.push({\n          start: listStart, end: offset,\n          style: { type: "list", ordered: node.ordered },\n        });\n        break;\n      case "inlineCode":\n        offset += node.value.length;\n        styleRanges.push({\n          start: startOffset, end: offset,\n          style: { type: "code", isInline: true },\n        });\n        break;\n      default:\n        if (node.children) node.children.forEach(traverse);\n        break;\n    }\n  };\n  traverse(ast);\n}\n\n// Create Adobe Express text styling instructions from a markdown AST\nexport function createExpressStylingFromAST(ast) {\n  // Extract the full text from the AST\n  const plainText = getFormattedText(ast);\n  const styleRanges = [];\n  // Process the AST to generate style ranges\n  processNodeForStyling(ast, styleRanges, plainText);\n  return { plainText, styleRanges }\n}\n\n// Helper function to print out style ranges for debugging\nexport function debugStyleRanges(text, styleRanges) {\n  console.log("---- Style Ranges Debug ----");\n  styleRanges.forEach((range, index) => {\n    const snippet = text.substring(range.start, range.end);\n    console.log(\n      `Range ${index}: ${range.start}-${range.end} (${range.style.type})`\n    );\n    console.log(`Text: "${snippet}"`);\n    console.log("Style:", range.style);\n    console.log("-----");\n  });\n}\n\n// Helper function to apply Adobe Express text styling\nexport async function applyExpressTextStyling(sandboxProxy, text, styleRanges) {\n  try {\n    // First create a text node with the plain text\n    const textNode = await sandboxProxy.createTextNode(text);\n\n    // Then apply styling to the text node\n    for (const range of styleRanges) {\n      switch (range.style.type) {\n        case "heading":\n          await sandboxProxy.applyHeadingStyle(\n            textNode, range.start, range.end, range.style.level\n          );\n          break;\n        case "emphasis":\n          await sandboxProxy.applyTextStyle(\n            textNode, range.start, range.end, { italic: true }\n          );\n          break;\n        case "strong":\n          await sandboxProxy.applyTextStyle(\n            textNode, range.start, range.end, { bold: true }\n          );\n          break;\n        case "link":\n          await sandboxProxy.applyLinkStyle(\n            textNode, range.start, range.end, range.style.url\n          );\n          break;\n        // You can add cases for other styles here...\n      }\n    }\n    return textNode;\n  } catch (error) {\n    console.error("Error applying Express text styling:", error);\n    throw error;\n  }\n}\n')),(0,o.mdx)("h3",{id:"43-the-sandbox-apply-the-styles"},"4.3 The Sandbox: Apply the Styles"),(0,o.mdx)("p",null,"Now, let's implement the final piece in ",(0,o.mdx)("inlineCode",{parentName:"p"},"sandbox/code.js"),". This script will receive the text and style ranges and use the Text API to perform the magic. We'll also define our styling rules in ",(0,o.mdx)("inlineCode",{parentName:"p"},"sandbox/constants.js")," which allows to easily change the visual output (fonts, sizes, spacing) of the parsed Markdown without having to search through the application logic."),(0,o.mdx)("p",null,"This ",(0,o.mdx)("inlineCode",{parentName:"p"},"sandbox/code.js")," is where the visual transformation happens. Here are the key points:"),(0,o.mdx)("ul",null,(0,o.mdx)("li",{parentName:"ul"},"The ",(0,o.mdx)("inlineCode",{parentName:"li"},"createStyledTextFromMarkdown")," function receives the plain text and style ranges from the UI."),(0,o.mdx)("li",{parentName:"ul"},"It first creates a single ",(0,o.mdx)("inlineCode",{parentName:"li"},"TextNode")," with the entire plain text content and adds it to the document."),(0,o.mdx)("li",{parentName:"ul"},(0,o.mdx)("strong",{parentName:"li"},"Performance Tip: Font Caching.")," The ",(0,o.mdx)("inlineCode",{parentName:"li"},"preloadFonts")," function and ",(0,o.mdx)("inlineCode",{parentName:"li"},"fontCache")," map are used to load all necessary fonts at once and store them. This avoids making multiple, slow requests for the same font."),(0,o.mdx)("li",{parentName:"ul"},(0,o.mdx)("strong",{parentName:"li"},"Safe Asynchronous Edits.")," ",(0,o.mdx)("a",{parentName:"li",href:"../../../../references/document-sandbox/document-apis/classes/Editor.md#queueasyncedit"},(0,o.mdx)("inlineCode",{parentName:"a"},"editor.queueAsyncEdit()"))," is essential for making changes to the document ",(0,o.mdx)("em",{parentName:"li"},"after")," an asynchronous operation (like ",(0,o.mdx)("inlineCode",{parentName:"li"},"preloadFonts"),"). The Add-on SDK requires that any edits following a pause for an ",(0,o.mdx)("inlineCode",{parentName:"li"},"await")," be wrapped in ",(0,o.mdx)("inlineCode",{parentName:"li"},"queueAsyncEdit()"),". This ensures that all changes are correctly tracked for the application's save and undo history. While this also has the benefit of batching multiple edits into a single, efficient operation, its primary role here is to guarantee document stability."),(0,o.mdx)("li",{parentName:"ul"},"Inside the queue, a base style is applied to the entire text block first. Then, the code iterates through the ",(0,o.mdx)("inlineCode",{parentName:"li"},"styleRanges")," array, applying each specific character or paragraph style to the correct portion of the text.")),(0,o.mdx)(c,{slots:"heading, code",repeat:"2",languages:"JavaScript",mdxType:"CodeBlock"}),(0,o.mdx)("h4",{id:"sandboxconstantsjs"},"sandbox/constants.js"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-javascript"},'export const MD_CONSTANTS = {\n  FONTS: {\n    HEADING: "SourceSans3-Bold",\n    EMPHASIS: "SourceSans3-It",\n    STRONG: "SourceSans3-Bold",\n    CODE: "AnonymousPro",\n    REGULAR: "SourceSans3-Regular",\n  },\n  HEADING_SIZES: {\n    1: 24, 2: 22, 3: 20, 4: 18, 5: 16, 6: 16, DEFAULT: 16\n  },\n  LAYOUT: {\n    MARGIN: 20,\n    DEFAULT_FONT_SIZE: 16,\n    LINE_SPACING: 1.5,\n    PARAGRAPH_SPACE_AFTER: 8,\n  },\n  DEBUG: false,\n};\n')),(0,o.mdx)("h4",{id:"sandboxcodejs-1"},"sandbox/code.js"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-javascript"},'import addOnSandboxSdk from "add-on-sdk-document-sandbox";\nimport { editor, fonts, constants } from "express-document-sdk";\nimport { MD_CONSTANTS } from "./constants.js";\n\nconst { runtime } = addOnSandboxSdk.instance;\nconst DEBUG_STYLES = MD_CONSTANTS.DEBUG;\n\n// Returns the font size for a specific markdown heading level\nfunction getFontSizeForHeadingLevel(level) {\n  return (\n    MD_CONSTANTS.HEADING_SIZES[level] ||\n    MD_CONSTANTS.HEADING_SIZES.DEFAULT\n  );\n}\n\n// Initializes the document sandbox functionality\nfunction start() {\n  // Cache loaded fonts to avoid reloading them\n  const fontCache = new Map();\n\n  // Preloads and caches fonts by their postscript names\n  async function preloadFonts(postscriptNames) {\n    await Promise.all(\n      postscriptNames.map(async (psName) => {\n        const font = await fonts.fromPostscriptName(psName);\n        if (font) { fontCache.set(psName, font) }\n        else { console.warn(`Font ${psName} couldn\'t be loaded.`) }\n      })\n    );\n  }\n\n  // APIs to be exposed to the UI runtime\n  const docApi = {\n    // Creates a text node in the current document\n    createTextNode: (text) => {\n      try {\n        // Find the current page\n        let currentNode = editor.context.insertionParent;\n        let page = null;\n        while (currentNode) {\n          if (currentNode.type === "Page") {\n            page = currentNode; break;\n          }\n          currentNode = currentNode.parent;\n        }\n\n        // Create a new text node\n        const textNode = editor.createText(text);\n        console.log("textNode created", text);\n\n        // Set the text content\n        textNode.textAlignment = constants.TextAlignment.left;\n        const artboard = page.artboards.first;\n        textNode.layout = {\n          type: constants.TextLayout.autoHeight,\n          width: artboard.width - MD_CONSTANTS.LAYOUT.MARGIN_WIDTH,\n        };\n        console.log("textNode layout", textNode.layout);\n\n        // Position the text at the top-left corner and fill the page width\n        textNode.setPositionInParent(\n          { x: MD_CONSTANTS.LAYOUT.MARGIN, y: MD_CONSTANTS.LAYOUT.MARGIN },\n          { x: 0, y: 0 }\n        );\n\n        console.log("textNode setPositionInParent");\n\n        // Apply default character styles\n        textNode.fullContent.applyCharacterStyles({\n          fontSize: MD_CONSTANTS.LAYOUT.DEFAULT_FONT_SIZE,\n        });\n        console.log("textNode applyCharacterStyles");\n\n        // Add to document\n        artboard.children.append(textNode);\n        console.log("textNode added to the artboard", textNode);\n        return textNode;\n\n      } catch (error) {\n        console.error("Error creating text node:", error);\n        throw error;\n      }\n    },\n\n    // Creates a styled text node from markdown content\n    createStyledTextFromMarkdown: async (markdownText, styleRanges) => {\n      try {\n        // Create text node first (this is allowed synchronously)\n        const textNode = docApi.createTextNode(markdownText);\n\n        // Preload fonts we\'ll need for styling\n        await preloadFonts([\n          MD_STYLES.FONTS.HEADING, MD_STYLES.FONTS.EMPHASIS,\n          MD_STYLES.FONTS.REGULAR, MD_STYLES.FONTS.CODE,\n        ]);\n\n        // Get cached fonts\n        const headingFont = fontCache.get(MD_STYLES.FONTS.HEADING);\n        const italicFont = fontCache.get(MD_STYLES.FONTS.EMPHASIS);\n        const boldFont = fontCache.get(MD_STYLES.FONTS.STRONG);\n        const monospaceFont = fontCache.get(MD_STYLES.FONTS.CODE);\n\n        // Now queue all style edits together for better performance\n        await editor.queueAsyncEdit(async () => {\n          for (const range of styleRanges) {\n            if (DEBUG_STYLES) {\n              console.log(`Applying ${range.style.type} style:`, range);\n            }\n            // Apply different styles based on the type\n            if (range.style.type === "list") {\n              docApi.applyListStyle(\n                textNode, range.start, range.end, range.style.ordered\n              );\n            } else if (range.style.type === "heading") {\n              if (DEBUG_STYLES) {\n                console.log(\n                  "Applying heading style for level:", range.style.level\n                );\n              }\n              // Apply heading styles\n              textNode.fullContent.applyCharacterStyles(\n                {\n                  font: headingFont,\n                  fontSize: getFontSizeForHeadingLevel(range.style.level),\n                },\n                { start: range.start, length: range.end - range.start }\n              );\n              if (DEBUG_STYLES) {\n                console.log("Applied heading style:", range.style.level);\n              }\n            } else if (range.style.type === "emphasis") {\n              if (DEBUG_STYLES) {\n                console.log("Applying emphasis style");\n              }\n              // Apply italic style\n              textNode.fullContent.applyCharacterStyles(\n                { font: italicFont },\n                { start: range.start, length: range.end - range.start }\n              );\n              if (DEBUG_STYLES) {\n                console.log("Applied emphasis style");\n              }\n            } else if (range.style.type === "strong") {\n              if (DEBUG_STYLES) {\n                console.log("Applying strong style");\n              }\n              // Apply bold style\n              textNode.fullContent.applyCharacterStyles(\n                { font: boldFont },\n                { start: range.start, length: range.end - range.start }\n              );\n              if (DEBUG_STYLES) {\n                console.log("Applied strong style");\n              }\n            } else if (range.style.type === "code") {\n              if (DEBUG_STYLES) {\n                console.log("Applying code style");\n              }\n              // Apply monospace font for code\n              textNode.fullContent.applyCharacterStyles(\n                { font: monospaceFont },\n                { start: range.start, length: range.end - range.start }\n              );\n              if (DEBUG_STYLES) {\n                console.log("Applied code style");\n              }\n            }\n            // Add any additional styles here...\n          }\n          console.log("All styles applied");\n        });\n      } catch (error) {\n        console.error("Error creating styled text from markdown:", error);\n        throw error;\n      }\n    },\n\n    // Applies ordered or unordered list styles to a text range\n    applyListStyle: (textNode, start, end, ordered) => {\n      try {\n        const listType = ordered\n          ? constants.ParagraphListType.ordered\n          : constants.ParagraphListType.unordered;\n\n        textNode.fullContent.applyParagraphStyles(\n          {\n            list: {\n              type: listType,\n              numbering: ordered\n                ? constants.OrderedListNumbering.numeric\n                : undefined,\n              prefix: ordered\n                ? MD_STYLES.LIST.ORDERED_PREFIX\n                : MD_STYLES.LIST.UNORDERED_PREFIX,\n              postfix: ordered\n                ? MD_STYLES.LIST.ORDERED_POSTFIX\n                : MD_STYLES.LIST.UNORDERED_POSTFIX,\n              indentLevel: MD_STYLES.LIST.DEFAULT_INDENT,\n            },\n            spaceBefore: MD_STYLES.LAYOUT.PARAGRAPH_SPACE_BEFORE,\n            spaceAfter: MD_STYLES.LAYOUT.PARAGRAPH_SPACE_AFTER,\n            lineSpacing: MD_STYLES.LAYOUT.LINE_SPACING,\n          },\n          { start, length: end - start }\n        );\n      } catch (error) {\n        console.error("Error applying list style:", error);\n        throw error;\n      }\n    },\n  };\n  runtime.exposeApi(docApi);\n}\nstart();\n')),(0,o.mdx)("h3",{id:"44-put-it-all-together"},"4.4 Put it all together"),(0,o.mdx)("p",null,"We have all the pieces in place: the file handler, the parser, the formatter, and the sandbox styler. Now let's connect them all."),(0,o.mdx)("p",null,"First, add the necessary imports to the top of ",(0,o.mdx)("inlineCode",{parentName:"p"},"src/ui/file-handler.js"),". Then, update the ",(0,o.mdx)("inlineCode",{parentName:"p"},"parseMarkdownAndInsert")," function for the final time. This version will no longer just log the AST, but will call the formatter and the sandbox to render the styled text in the document."),(0,o.mdx)("p",null,"This final change ",(0,o.mdx)("strong",{parentName:"p"},"connects all the pieces")," of our application:"),(0,o.mdx)("ul",null,(0,o.mdx)("li",{parentName:"ul"},"The ",(0,o.mdx)("inlineCode",{parentName:"li"},"parseMarkdownAndInsert")," function now implements our complete workflow:",(0,o.mdx)("ol",{parentName:"li"},(0,o.mdx)("li",{parentName:"ol"},"It calls the ",(0,o.mdx)("inlineCode",{parentName:"li"},"parseMarkdown()")," function to get the AST."),(0,o.mdx)("li",{parentName:"ol"},"It passes the AST to ",(0,o.mdx)("inlineCode",{parentName:"li"},"createExpressStylingFromAST()")," to get the plain text and the list of style ranges."),(0,o.mdx)("li",{parentName:"ol"},"It sends this data to the document sandbox using ",(0,o.mdx)("inlineCode",{parentName:"li"},"sandboxProxy.createStyledTextFromMarkdown()"),"."))),(0,o.mdx)("li",{parentName:"ul"},"The use of a ",(0,o.mdx)("inlineCode",{parentName:"li"},"DEBUG")," flag from our constants file is a convenient way to toggle console logging for the intermediate ",(0,o.mdx)("inlineCode",{parentName:"li"},"plainText")," and ",(0,o.mdx)("inlineCode",{parentName:"li"},"styleRanges"),", which is very helpful during development.")),(0,o.mdx)(c,{slots:"heading, code",repeat:"1",languages:"JavaScript",mdxType:"CodeBlock"}),(0,o.mdx)("h4",{id:"uifile-handlerjs-2"},"ui/file-handler.js"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-javascript"},'import { parseMarkdown } from "./markdown-parser.js";\nimport {                                                  // üëà\n  createExpressStylingFromAST                             // üëà\n} from "./adobe-express-formatter.js";                    // üëà\n\nexport default function setupFileHandler(sandboxProxy) {\n  customElements.whenDefined("sp-dropzone").then(() => {\n\n    // üëÜ (keep the rest of the file the same) üëÜ\n\n    const parseMarkdownAndInsert = async () => {\n      if (!markdownContent) {\n        console.error("No markdown content to parse");\n        return;\n      }\n\n      try {\n        progressCircle.style.display = "block";\n        message.heading = "Processing markdown...";\n        parseButton.disabled = true;\n\n        // 1. Parse the markdown to get the AST\n        const ast = await parseMarkdown(markdownContent);\n\n        // 2. Create styling instructions from the AST     // üëà\n        const { plainText, styleRanges } =                 // üëà\n          createExpressStylingFromAST(ast);                // üëà\n\n        // 3. Send the text and styles to the sandbox      // üëà\n        message.heading = "Adding text to document...";    // üëà\n        await sandboxProxy.createStyledTextFromMarkdown(   // üëà\n          plainText, styleRanges                           // üëà\n        );                                                 // üëà\n\n        message.heading = "Markdown successfully added!";\n      } catch (error) {\n        console.error("Error during parsing and styling:", error);\n        message.heading = "An error occurred";\n      } finally {\n        progressCircle.style.display = "none";\n        parseButton.disabled = false;\n      }\n    };\n\n    // üëá (keep the rest of the file the same) üëá\n\n  });\n}\n')),(0,o.mdx)("p",null,(0,o.mdx)("span",{parentName:"p",className:"gatsby-resp-image-wrapper",style:{position:"relative",display:"block",marginLeft:"auto",marginRight:"auto",maxWidth:"1280px"}},"\n      ",(0,o.mdx)("span",{parentName:"span",className:"gatsby-resp-image-background-image",style:{paddingBottom:"57.50000000000001%",position:"relative",bottom:"0",left:"0",display:"block",transition:"opacity 0.5s 0.5s",pointerEvents:"none"}}),"\n  ",(0,o.mdx)("picture",{parentName:"span"},"\n          ",(0,o.mdx)("source",{parentName:"picture",srcSet:["/express-add-ons-docs/static/f52e8ae7d976c568e717d13a89ef5793/5530d/markdown--text-api.webp 320w","/express-add-ons-docs/static/f52e8ae7d976c568e717d13a89ef5793/0c8fb/markdown--text-api.webp 640w","/express-add-ons-docs/static/f52e8ae7d976c568e717d13a89ef5793/94b1e/markdown--text-api.webp 1280w","/express-add-ons-docs/static/f52e8ae7d976c568e717d13a89ef5793/0b34d/markdown--text-api.webp 1920w","/express-add-ons-docs/static/f52e8ae7d976c568e717d13a89ef5793/f3963/markdown--text-api.webp 2500w"],sizes:"(max-width: 1280px) 100vw, 1280px",type:"image/webp"}),"\n          ",(0,o.mdx)("source",{parentName:"picture",srcSet:["/express-add-ons-docs/static/f52e8ae7d976c568e717d13a89ef5793/dd4a7/markdown--text-api.png 320w","/express-add-ons-docs/static/f52e8ae7d976c568e717d13a89ef5793/0f09e/markdown--text-api.png 640w","/express-add-ons-docs/static/f52e8ae7d976c568e717d13a89ef5793/bbbf7/markdown--text-api.png 1280w","/express-add-ons-docs/static/f52e8ae7d976c568e717d13a89ef5793/ac7a9/markdown--text-api.png 1920w","/express-add-ons-docs/static/f52e8ae7d976c568e717d13a89ef5793/6482f/markdown--text-api.png 2500w"],sizes:"(max-width: 1280px) 100vw, 1280px",type:"image/png"}),"\n          ",(0,o.mdx)("img",{parentName:"picture",className:"gatsby-resp-image-image",src:"/express-add-ons-docs/static/f52e8ae7d976c568e717d13a89ef5793/bbbf7/markdown--text-api.png",alt:"Markdown Parser with Text API",title:"Markdown Parser with Text API",loading:"lazy",style:{width:"100%",height:"100%",margin:"0",verticalAlign:"middle",position:"absolute",opacity:"0",transition:"opacity 0.5s",color:"inherit",boxShadow:"inset 0px 0px 0px 400px none",top:"0",left:"0"}}),"\n        "),"\n    ")),(0,o.mdx)("h2",{id:"5-conclusion"},"5. Conclusion"),(0,o.mdx)("p",null,"Congratulations! You have successfully built a functional Markdown Parser add-on for Adobe Express. You've learned how to:"),(0,o.mdx)("ul",null,(0,o.mdx)("li",{parentName:"ul"},"Structure a complex add-on project."),(0,o.mdx)("li",{parentName:"ul"},"Build a user-friendly UI with Spectrum Web Components for file handling."),(0,o.mdx)("li",{parentName:"ul"},"Use ",(0,o.mdx)("inlineCode",{parentName:"li"},"unified")," and ",(0,o.mdx)("inlineCode",{parentName:"li"},"remark")," to parse Markdown into an Abstract Syntax Tree."),(0,o.mdx)("li",{parentName:"ul"},"Develop a strategy to translate an AST into styling information."),(0,o.mdx)("li",{parentName:"ul"},"Leverage the powerful Adobe Express Text API to apply character and paragraph styles, manage fonts, and create rich text content programmatically.")),(0,o.mdx)("p",null,"This project serves as a strong foundation. You can extend it by supporting more Markdown features like tables, blockquotes, or even custom styling options for your users. Happy coding!"),(0,o.mdx)("h3",{id:"51-final-code"},"5.1 Final code"),(0,o.mdx)("p",null,"You can find the final code for this tutorial in the ",(0,o.mdx)("a",{parentName:"p",href:"https://github.com/AdobeDocs/express-add-on-samples/tree/main/document-sandbox-samples/express-markdown-parser-addon/"},"GitHub add-on samples repository"),"; there are two folders:"),(0,o.mdx)("ul",null,(0,o.mdx)("li",{parentName:"ul"},(0,o.mdx)("inlineCode",{parentName:"li"},"markdown-parser-add-on-start")," is the starting point for the tutorial as described ",(0,o.mdx)("a",{parentName:"li",href:"#12-initial-code"},"here"),"."),(0,o.mdx)("li",{parentName:"ul"},(0,o.mdx)("inlineCode",{parentName:"li"},"markdown-parser-add-on-end")," is the final code for the add-on.")),(0,o.mdx)(c,{slots:"heading, code",repeat:"8",languages:"index.html, styles.css, index.js, file-handler.js, markdown-parser.js, adobe-express-formatter.js, code.js, constants.js",mdxType:"CodeBlock"}),(0,o.mdx)("h4",{id:"iframe"},"iframe"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-html"},'\x3c!-- index.html --\x3e\n\n <!DOCTYPE html>\n<html lang="en">\n<head>\n  <meta charset="UTF-8" />\n  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>\n  <title>Markdown Parser add-on</title>\n  <link rel="stylesheet" href="styles.css"/>\n</head>\n\n<body>\n  <sp-theme scale="medium" color="light" system="express">\n    <h2>Markdown Parser</h2>\n    <div class="row">\n      <sp-dropzone tabindex="0" id="dropzone" drop-effect="copy">\n        <sp-illustrated-message id="message"\n          style="--mod-illustrated-message-display: flex;"\n          heading="Drag and drop your file">\n          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 150 103"\n               width="150" height="103">\n            <path\n              d="M133.7,8.5h-118c-1.9,0-3.5,1.6-3.5,3.5v27c0,0.8,0.7,1.5,1.5,1.5s1.5-0.7,1.5-1.5V23.5h119V92c0,0.3-0.2,0.5-0.5,0.5h-118c-0.3,0-0.5-0.2-0.5-0.5V69c0-0.8-0.7-1.5-1.5-1.5s-1.5,0.7-1.5,1.5v23c0,1.9,1.6,3.5,3.5,3.5h118c1.9,0,3.5-1.6,3.5-3.5V12C137.2,10.1,135.6,8.5,133.7,8.5z M15.2,21.5V12c0-0.3,0.2-0.5,0.5-0.5h118c0.3,0,0.5,0.2,0.5,0.5v9.5H15.2z M32.6,16.5c0,0.6-0.4,1-1,1h-10c-0.6,0-1-0.4-1-1s0.4-1,1-1h10C32.2,15.5,32.6,15.9,32.6,16.5z M13.6,56.1l-8.6,8.5C4.8,65,4.4,65.1,4,65.1c-0.4,0-0.8-0.1-1.1-0.4c-0.6-0.6-0.6-1.5,0-2.1l8.6-8.5l-8.6-8.5c-0.6-0.6-0.6-1.5,0-2.1c0.6-0.6,1.5-0.6,2.1,0l8.6,8.5l8.6-8.5c0.6-0.6,1.5-0.6,2.1,0c0.6,0.6,0.6,1.5,0,2.1L15.8,54l8.6,8.5c0.6,0.6,0.6,1.5,0,2.1c-0.3,0.3-0.7,0.4-1.1,0.4c-0.4,0-0.8-0.1-1.1-0.4L13.6,56.1z">\n            </path>\n          </svg>\n        </sp-illustrated-message>\n        <div>\n          <label for="file-input">\n            <sp-link href="#"\n              onclick="document.getElementById(\'file-input\').click()">\n              Select a Markdown File\n            </sp-link>\n            from your computer\n          </label>\n          <input type="file" id="file-input" style="display: none" />\n        </div>\n      </sp-dropzone>\n    </div>\n\n    <div class="row button-row">\n      <sp-button id="parseButton" variant="accent" disabled>\n        Parse Markdown\n      </sp-button>\n      <sp-progress-circle size="s" indeterminate id="progress-circle">\n      </sp-progress-circle>\n    </div>\n\n    <div class="row info-text">\n      <p>\n        Parses Markdown and creates styled text in your Adobe Express\n        document. Supported formats: Headings, Bold, Italic, and Lists.\n      </p>\n    </div>\n  </sp-theme>\n</body>\n</html>\n')),(0,o.mdx)("h4",{id:"iframe-1"},"iframe"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-css"},"/* styles.css */\nbody { margin: 0; padding: 0; overflow-x: hidden; }\n\nsp-theme {\n  margin: 0 var(--spectrum-global-dimension-static-size-300);\n  display: grid;\n}\n\nh2 { font-weight: var(--spectrum-global-font-weight-black); }\n\nsp-button { flex: 1; }\n\nsp-dropzone { max-width: 272px; }\n\nsp-progress-circle { margin-left: 10px; }\n\n.row {\n  display: flex; flex-direction: row; justify-content: space-between;\n  width: 100%; align-items: flex-end;\n}\n\n.button-row {\n  margin-top: 20px; display: flex; align-items: center;\n  justify-content: center;\n}\n\n.gap-20 { gap: var(--spectrum-global-dimension-static-size-250); }\n\n.gutter-row {\n  display: flex; flex-direction: row; justify-content: flex-end;\n  align-items: flex-start; border: 1px solid black; width: 100%;\n  margin-bottom: var(--spectrum-global-dimension-static-size-150);\n}\n\n.info-text { margin-top: 10px; font-size: 12px; color: #6e6e6e; }\n")),(0,o.mdx)("h4",{id:"iframe-2"},"iframe"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-javascript"},'// ui/index.js\n\nimport "@spectrum-web-components/styles/typography.css";\n\nimport "@spectrum-web-components/theme/src/themes.js";\nimport "@spectrum-web-components/theme/theme-light.js";\nimport "@spectrum-web-components/theme/express/theme-light.js";\nimport "@spectrum-web-components/theme/express/scale-medium.js";\nimport "@spectrum-web-components/theme/sp-theme.js";\n\nimport "@spectrum-web-components/button/sp-button.js";\nimport "@spectrum-web-components/link/sp-link.js";\nimport "@spectrum-web-components/illustrated-message/sp-illustrated-message.js";\nimport "@spectrum-web-components/dropzone/sp-dropzone.js";\nimport "@spectrum-web-components/progress-circle/sp-progress-circle.js";\n\nimport addOnUISdk from "https://express.adobe.com/static/add-on-sdk/sdk.js";\nimport setupFileHandler from "./file-handler.js";\n\naddOnUISdk.ready.then(async () => {\n  console.log("addOnUISdk is ready for use.");\n\n  // Get the Authoring Sandbox\n  const { runtime } = addOnUISdk.instance;\n  const sandboxProxy = await runtime.apiProxy("documentSandbox");\n  setupFileHandler(sandboxProxy);\n});\n')),(0,o.mdx)("h4",{id:"iframe-3"},"iframe"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-javascript"},'// ui/file-handler.js\n\nimport { parseMarkdown } from "./markdown-parser.js"; // Already there\nimport { createExpressStylingFromAST } from "./adobe-express-formatter.js";\n\nexport default function setupFileHandler(sandboxProxy) {\n  customElements.whenDefined("sp-dropzone").then(() => {\n    const dropzone = document.getElementById("dropzone");\n    const parseButton = document.getElementById("parseButton");\n    const message = document.getElementById("message");\n    const fileInput = document.getElementById("file-input");\n    const progressCircle = document.getElementById("progress-circle");\n    let input;\n    let beingDraggedOver = false;\n    let markdownContent = null;\n\n    // Hide progress initially\n    if (progressCircle) { progressCircle.style.display = "none" }\n\n    const isMarkdownFile = (file) => {\n      return (\n        file.name.toLowerCase().endsWith(".md") ||\n        file.type === "text/markdown"\n      );\n    };\n\n    const updateMessage = () => {\n      message.heading =\n        input !== undefined\n          ? beingDraggedOver\n            ? "Drop here to replace!"\n            : "Got it!"\n          : "Drag and drop your file";\n    };\n\n    const handleDropOrChange = (event) => {\n      let file;\n\n      // Handle different event sources\n      if (event.type === "drop") {\n        file = event.dataTransfer.files[0];\n      } else if (event.type === "change") {\n        file = event.target.files[0];\n      } else if (event.detail && event.detail.dropEvent) {\n        // Handle sp-dropzone-drop event\n        file = event.detail.dropEvent.dataTransfer.files[0];\n      }\n      if (!file) {\n        console.error("No file found in the event"); return;\n      }\n      if (!isMarkdownFile(file)) {\n        message.heading = "Please drop a markdown (.md) file"; return;\n      }\n\n      // Set input to a temporary value to show "Got it!" immediately\n      input = "loading";\n      dropzone.setAttribute("filled", true);\n      beingDraggedOver = false;\n      updateMessage();\n\n      const reader = new FileReader();\n      reader.onload = (e) => {\n        const content = e.target.result;\n        input = content;\n        markdownContent = content;\n        console.log("Markdown content:", content);\n        // Enable parse button now that we have content\n        parseButton.disabled = false;\n        // Ensure message is updated after content is loaded\n        updateMessage();\n      };\n      reader.readAsText(file);\n    };\n\n    const parseMarkdownAndInsert = async () => {\n      if (!markdownContent) {\n        console.error("No markdown content to parse");\n        return;\n      }\n\n      try {\n        progressCircle.style.display = "block";\n        message.heading = "Processing markdown...";\n        parseButton.disabled = true;\n\n        // 1. Parse the markdown to get the AST\n        const ast = await parseMarkdown(markdownContent);\n\n        // 2. Create styling instructions from the AST\n        const {\n          plainText, styleRanges\n        } = createExpressStylingFromAST(ast);\n        // 3. Send the text and styles to the sandbox\n        message.heading = "Adding text to document...";\n        await sandboxProxy.createStyledTextFromMarkdown(\n          plainText, styleRanges\n        );\n\n        message.heading = "Markdown successfully added!";\n      } catch (error) {\n        console.error("Error during parsing and styling:", error);\n        message.heading = "An error occurred";\n      } finally {\n        progressCircle.style.display = "none";\n        parseButton.disabled = false;\n      }\n    };\n\n    // Event listeners\n    dropzone.addEventListener("dragover", (event) => {\n      event.preventDefault();\n      beingDraggedOver = true;\n      updateMessage();\n    });\n    dropzone.addEventListener("dragleave", () => {\n      beingDraggedOver = false;\n      updateMessage();\n    });\n    dropzone.addEventListener("drop", (event) => {\n      event.preventDefault();\n      handleDropOrChange(event);\n    });\n    // Also listen for the Spectrum Web Component\'s native event\n    dropzone.addEventListener("sp-dropzone-drop", (event) => {\n      event.preventDefault();\n      handleDropOrChange(event);\n    });\n    fileInput.addEventListener("change", (event) => {\n      handleDropOrChange(event);\n    });\n\n    // Parse button click handler\n    parseButton.addEventListener("click", parseMarkdownAndInsert);\n    // Initially disable parse button until we have content\n    parseButton.disabled = true;\n  });\n}\n')),(0,o.mdx)("h4",{id:"iframe-4"},"iframe"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-javascript"},'// ui/markdown-parser.js\n\nimport { unified } from "unified";\nimport remarkParse from "remark-parse";\nimport remarkStringify from "remark-stringify";\nimport { toString } from "mdast-util-to-string";\n\n// Parse markdown content into an abstract syntax tree (AST)\nexport async function parseMarkdown(markdownContent) {\n  try {\n    // Create a unified processor with remark-parse\n    const processor = unified().use(remarkParse);\n    // Parse the markdown content into an AST\n    const ast = processor.parse(markdownContent);\n    // Run any transformations needed\n    const result = await processor.run(ast);\n    return result;\n  } catch (e) {\n    console.error("Error parsing markdown in markdown-parser.js:", e);\n    throw e;\n  }\n}\n\n// Replace multiple consecutive spaces, tabs,\n// and newlines with a single space\nfunction cleanText(text) { return text.replace(/\\s+/g, " ").trim() }\n\n// Get properly formatted text from the AST\nexport function getFormattedText(ast) {\n  let text = "";\n\n  // Process nodes to create proper paragraph breaks\n  const processNode = (node) => {\n    if (!node) return "";\n    if (node.type === "root") {\n      // Process each child node\n      node.children.forEach((child, index) => {\n        const childText = processNode(child);\n        text += childText;\n        // Add paragraph breaks between block elements\n        if (\n          index < node.children.length - 1 &&\n          ["paragraph", "heading", "list"].includes(child.type)\n        ) {  text += "\\n\\n" }\n      });\n      return text;\n    }\n\n    // Handle specific node types\n    switch (node.type) {\n      case "paragraph": return cleanText(toString(node));\n      case "heading":   return cleanText(toString(node));\n      case "list":\n        let listText = "";\n        node.children.forEach((item, index) => {\n          // const marker = node.ordered ? `${index + 1}. ` : "‚Ä¢ ";\n          const itemText = cleanText(toString(item));\n          // listText += marker + itemText;\n          listText += itemText;\n          if (index < node.children.length - 1) { listText += "\\n" }\n        });\n        return listText;\n      default:\n        // For other node types, just return the text\n        return cleanText(toString(node));\n    }\n  };\n  return processNode(ast);\n}\n\n// Convert AST back to markdown string (for testing/debugging)\nexport async function astToMarkdown(ast) {\n  try {\n    const processor = unified().use(remarkStringify);\n    const result = processor.stringify(ast);\n    return result;\n  } catch (e) {\n    console.error("Error converting AST to markdown:", e);\n    throw e;\n  }\n}\n\n// Extract plain text from the AST\nexport function extractTextFromAst(ast) { return toString(ast) }\n\n// Process markdown by parsing to AST + transforming for Adobe Express\nexport async function processMarkdown(markdownContent) {\n\n  const ast = await parseMarkdown(markdownContent);\n  // Extract all headings for potential TOC\n  const headings = [];\n  const processNode = (node) => {\n    if (node.type === "heading") {\n      headings.push({\n        depth: node.depth, text: toString(node),\n        children: node.children\n      });\n    }\n    if (node.children) { node.children.forEach(processNode) }\n  }\n  processNode(ast);\n\n  // Get both formatted text (with proper paragraphs) and raw text\n  const formattedText = getFormattedText(ast);\n\n  return { ast, headings, plainText: formattedText, formattedText }\n}\n')),(0,o.mdx)("h4",{id:"iframe-5"},"iframe"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-javascript"},'// ui/adobe-express-formatter.js\n\nimport { getFormattedText, extractTextFromAst } from "./markdown-parser.js";\n\n// Creates a mapping of text ranges and their styling commands for Adobe Express\nfunction processNodeForStyling(ast, styleRanges) {\n  let offset = 0;\n\n  const traverse = (node) => {\n    if (!node) return;\n\n    const startOffset = offset;\n    // Helper function to process styled nodes with common pattern\n    const processStyledNode = (node, styleType, styleProps = {}) => {\n      const rangeStart = offset;\n      node.children.forEach(traverse);\n      const rangeEnd = offset;\n\n      styleRanges.push({\n        start: rangeStart,\n        end: rangeEnd,\n        style: { type: styleType, ...styleProps },\n      });\n    };\n\n    switch (node.type) {\n      case "root":\n        node.children.forEach((child, index) => {\n          traverse(child);\n          if (\n            index < node.children.length - 1 &&\n            ["paragraph", "heading", "list"].includes(child.type)\n          ) {\n            offset += 2; // \\n\\n between blocks\n          }\n        });\n        break;\n\n      case "paragraph":\n        node.children.forEach(traverse);\n        break;\n\n      case "heading":\n        processStyledNode(node, "heading", { level: node.depth });\n        break;\n\n      case "text":\n        offset += node.value.length;\n        break;\n\n      case "emphasis":\n        processStyledNode(node, "emphasis", { italic: true });\n        break;\n\n      case "strong":\n        processStyledNode(node, "strong", { bold: true });\n        break;\n\n      // example AST traversal logic for lists:\n      case "list":\n        const listStart = offset;\n        node.children.forEach((item, index) => {\n          item.children.forEach(traverse);\n          if (index < node.children.length - 1) offset += 1; // newline between items\n        });\n\n        styleRanges.push({\n          start: listStart,\n          end: offset,\n          style: { type: "list", ordered: node.ordered },\n        });\n        break;\n\n      case "inlineCode":\n        offset += node.value.length;\n        styleRanges.push({\n          start: startOffset,\n          end: offset,\n          style: { type: "code", isInline: true },\n        });\n        break;\n\n      default:\n        if (node.children) node.children.forEach(traverse);\n        break;\n    }\n  };\n  traverse(ast);\n}\n\n// Create Adobe Express text styling instructions from a markdown AST\nexport function createExpressStylingFromAST(ast) {\n  // Extract the full text from the AST\n  const plainText = getFormattedText(ast);\n  const styleRanges = [];\n\n  // Process the AST to generate style ranges\n  processNodeForStyling(ast, styleRanges, plainText);\n\n  return { plainText, styleRanges };\n}\n\n// Helper function to print out style ranges for debugging\nexport function debugStyleRanges(text, styleRanges) {\n  console.log("---- Style Ranges Debug ----");\n  styleRanges.forEach((range, index) => {\n    const snippet = text.substring(range.start, range.end);\n    console.log(\n      `Range ${index}: ${range.start}-${range.end} (${range.style.type})`\n    );\n    console.log(`Text: "${snippet}"`);\n    console.log("Style:", range.style);\n    console.log("-----");\n  });\n}\n\n// Helper function to apply Adobe Express text styling\nexport async function applyExpressTextStyling(sandboxProxy, text, styleRanges) {\n  try {\n    // First create a text node with the plain text\n    const textNode = await sandboxProxy.createTextNode(text);\n\n    // Then apply styling to the text node\n    for (const range of styleRanges) {\n      switch (range.style.type) {\n        case "heading":\n          await sandboxProxy.applyHeadingStyle(\n            textNode,\n            range.start,\n            range.end,\n            range.style.level\n          );\n          break;\n\n        case "emphasis":\n          await sandboxProxy.applyTextStyle(textNode, range.start, range.end, {\n            italic: true,\n          });\n          break;\n\n        case "strong":\n          await sandboxProxy.applyTextStyle(textNode, range.start, range.end, {\n            bold: true,\n          });\n          break;\n\n        case "link":\n          await sandboxProxy.applyLinkStyle(\n            textNode,\n            range.start,\n            range.end,\n            range.style.url\n          );\n          break;\n\n        // You can add cases for other styles here...\n      }\n    }\n    return textNode;\n  } catch (error) {\n    console.error("Error applying Express text styling:", error);\n    throw error;\n  }\n}\n')),(0,o.mdx)("h4",{id:"document-api"},"Document API"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-javascript"},'// sandbox/code.js\n\nimport addOnSandboxSdk from "add-on-sdk-document-sandbox";\nimport { editor, fonts, constants } from "express-document-sdk";\nimport { MD_CONSTANTS } from "./constants.js";\n\nconst { runtime } = addOnSandboxSdk.instance;\nconst DEBUG_STYLES = MD_CONSTANTS.DEBUG;\n\n// Returns the font size for a specific markdown heading level\nfunction getFontSizeForHeadingLevel(level) {\n  return (\n    MD_CONSTANTS.HEADING_SIZES[level] || MD_CONSTANTS.HEADING_SIZES.DEFAULT\n  );\n}\n\n// Initializes the document sandbox functionality\nfunction start() {\n  // Cache loaded fonts to avoid reloading them\n  const fontCache = new Map();\n\n  // Preloads and caches fonts by their postscript names\n  async function preloadFonts(postscriptNames) {\n    await Promise.all(\n      postscriptNames.map(async (psName) => {\n        const font = await fonts.fromPostscriptName(psName);\n        if (font) {\n          fontCache.set(psName, font);\n        } else {\n          console.warn(`Font ${psName} couldn\'t be loaded.`);\n        }\n      })\n    );\n  }\n\n  // APIs to be exposed to the UI runtime\n  const docApi = {\n    // Creates a text node in the current document\n    createTextNode: (text) => {\n      try {\n        // Find the current page\n        let currentNode = editor.context.insertionParent;\n        let page = null;\n        while (currentNode) {\n          if (currentNode.type === "Page") {\n            page = currentNode;\n            break;\n          }\n          currentNode = currentNode.parent;\n        }\n\n        // Create a new text node\n        const textNode = editor.createText(text);\n        console.log("textNode created", text);\n\n        // Set the text content\n        textNode.textAlignment = constants.TextAlignment.left;\n        const artboard = page.artboards.first;\n        console.log(\n          "constants.TextLayout.autoHeight",\n          constants.TextLayout.autoHeight\n        );\n        textNode.layout = {\n          type: constants.TextLayout.autoHeight,\n          width: artboard.width - MD_CONSTANTS.LAYOUT.MARGIN_WIDTH,\n        };\n        console.log("textNode layout", textNode.layout);\n\n        // Position the text at the top-left corner and fill the page width\n        textNode.setPositionInParent(\n          { x: MD_CONSTANTS.LAYOUT.MARGIN, y: MD_CONSTANTS.LAYOUT.MARGIN },\n          { x: 0, y: 0 }\n        );\n\n        console.log("textNode setPositionInParent");\n\n        // Apply default character styles\n        textNode.fullContent.applyCharacterStyles({\n          fontSize: MD_CONSTANTS.LAYOUT.DEFAULT_FONT_SIZE,\n        });\n        console.log("textNode applyCharacterStyles");\n\n        // Add to document\n        artboard.children.append(textNode);\n        console.log("textNode added to the artboard", textNode);\n        return textNode;\n      } catch (error) {\n        console.error("Error creating text node:", error);\n        throw error;\n      }\n    },\n\n    // Creates a styled text node from markdown content\n    createStyledTextFromMarkdown: async (markdownText, styleRanges) => {\n      try {\n        // Create text node first (this is allowed synchronously)\n        const textNode = docApi.createTextNode(markdownText);\n\n        // Preload fonts we\'ll need for styling\n        await preloadFonts([\n          MD_CONSTANTS.FONTS.HEADING,\n          MD_CONSTANTS.FONTS.EMPHASIS,\n          MD_CONSTANTS.FONTS.REGULAR,\n          MD_CONSTANTS.FONTS.CODE,\n        ]);\n\n        // Get cached fonts\n        const headingFont = fontCache.get(MD_CONSTANTS.FONTS.HEADING);\n        const italicFont = fontCache.get(MD_CONSTANTS.FONTS.EMPHASIS);\n        const boldFont = fontCache.get(MD_CONSTANTS.FONTS.STRONG);\n        const monospaceFont = fontCache.get(MD_CONSTANTS.FONTS.CODE);\n\n        // Now queue all style edits together for better performance\n        await editor.queueAsyncEdit(async () => {\n          for (const range of styleRanges) {\n            if (DEBUG_STYLES) {\n              console.log(`Applying ${range.style.type} style:`, range);\n            }\n            // Apply different styles based on the type\n            if (range.style.type === "list") {\n              docApi.applyListStyle(\n                textNode,\n                range.start,\n                range.end,\n                range.style.ordered\n              );\n            } else if (range.style.type === "heading") {\n              if (DEBUG_STYLES) {\n                console.log(\n                  "Applying heading style for level:",\n                  range.style.level\n                );\n              }\n              // Apply heading styles\n              textNode.fullContent.applyCharacterStyles(\n                {\n                  font: headingFont,\n                  fontSize: getFontSizeForHeadingLevel(range.style.level),\n                },\n                { start: range.start, length: range.end - range.start }\n              );\n              if (DEBUG_STYLES) {\n                console.log("Applied heading style:", range.style.level);\n              }\n            } else if (range.style.type === "emphasis") {\n              if (DEBUG_STYLES) {\n                console.log("Applying emphasis style");\n              }\n              // Apply italic style\n              textNode.fullContent.applyCharacterStyles(\n                { font: italicFont },\n                { start: range.start, length: range.end - range.start }\n              );\n              if (DEBUG_STYLES) {\n                console.log("Applied emphasis style");\n              }\n            } else if (range.style.type === "strong") {\n              if (DEBUG_STYLES) {\n                console.log("Applying strong style");\n              }\n              // Apply bold style\n              textNode.fullContent.applyCharacterStyles(\n                { font: boldFont },\n                { start: range.start, length: range.end - range.start }\n              );\n              if (DEBUG_STYLES) {\n                console.log("Applied strong style");\n              }\n            } else if (range.style.type === "code") {\n              if (DEBUG_STYLES) {\n                console.log("Applying code style");\n              }\n              // Apply monospace font for code\n              textNode.fullContent.applyCharacterStyles(\n                { font: monospaceFont },\n                { start: range.start, length: range.end - range.start }\n              );\n              if (DEBUG_STYLES) {\n                console.log("Applied code style");\n              }\n            }\n            // Add any additional styles here...\n          }\n          console.log("All styles applied");\n        });\n      } catch (error) {\n        console.error("Error creating styled text from markdown:", error);\n        throw error;\n      }\n    },\n\n    // Applies ordered or unordered list styles to a text range\n    applyListStyle: (textNode, start, end, ordered) => {\n      try {\n        const listType = ordered\n          ? constants.ParagraphListType.ordered\n          : constants.ParagraphListType.unordered;\n\n        textNode.fullContent.applyParagraphStyles(\n          {\n            list: {\n              type: listType,\n              numbering: ordered\n                ? constants.OrderedListNumbering.numeric\n                : undefined,\n              prefix: ordered\n                ? MD_CONSTANTS.LIST.ORDERED_PREFIX\n                : MD_CONSTANTS.LIST.UNORDERED_PREFIX,\n              postfix: ordered\n                ? MD_CONSTANTS.LIST.ORDERED_POSTFIX\n                : MD_CONSTANTS.LIST.UNORDERED_POSTFIX,\n              indentLevel: MD_CONSTANTS.LIST.DEFAULT_INDENT,\n            },\n            spaceBefore: MD_CONSTANTS.LAYOUT.PARAGRAPH_SPACE_BEFORE,\n            spaceAfter: MD_CONSTANTS.LAYOUT.PARAGRAPH_SPACE_AFTER,\n            lineSpacing: MD_CONSTANTS.LAYOUT.LINE_SPACING,\n          },\n          { start, length: end - start }\n        );\n      } catch (error) {\n        console.error("Error applying list style:", error);\n        throw error;\n      }\n    },\n  };\n  runtime.exposeApi(docApi);\n}\nstart();\n')),(0,o.mdx)("h4",{id:"document-api-1"},"Document API"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-javascript"},'// sandbox/constants.js\n\nexport const MD_CONSTANTS = {\n  // Font settings\n  FONTS: {\n    HEADING: "SourceSans3-Bold",\n    EMPHASIS: "SourceSans3-It",\n    STRONG: "SourceSans3-Bold",\n    CODE: "AnonymousPro",\n    REGULAR: "SourceSans3-Regular",\n  },\n\n  // Font sizes for different heading levels\n  HEADING_SIZES: {\n    1: 24,\n    2: 22,\n    3: 20,\n    4: 18,\n    5: 16,\n    6: 16,\n    DEFAULT: 16,\n  },\n\n  // Text layout settings\n  LAYOUT: {\n    MARGIN: 20,\n    DEFAULT_FONT_SIZE: 16,\n    LINE_SPACING: 1.5,\n    PARAGRAPH_SPACE_BEFORE: 8,\n    PARAGRAPH_SPACE_AFTER: 4,\n    MARGIN_WIDTH: 40,\n  },\n\n  // List styling\n  LIST: {\n    UNORDERED_PREFIX: "‚Ä¢",\n    ORDERED_PREFIX: "",\n    ORDERED_POSTFIX: ".",\n    UNORDERED_POSTFIX: "",\n    DEFAULT_INDENT: 0,\n  },\n\n  // Debug mode\n  DEBUG: false,\n};\n')),(0,o.mdx)("h3",{id:"52-next-steps"},"5.2 Next steps"),(0,o.mdx)("p",null,"If you want to learn more about Text API you can check the ",(0,o.mdx)("a",{parentName:"p",href:"../use_text.md"},"Text How-to"),", which contains several examples on how to apply Character and Paragraph styles, as well as using fonts and colors."))}g.isMDXComponent=!0}}]);
//# sourceMappingURL=component---src-pages-guides-learn-how-to-tutorials-markdown-parser-text-api-md-80e76d89ac66cae32389.js.map